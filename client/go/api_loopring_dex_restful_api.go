/*
LightCone 2.0 API Documentation

LightCone DEX function interpretation

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package loopring

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
)

// LoopringDEXRestfulAPIApiService LoopringDEXRestfulAPIApi service
type LoopringDEXRestfulAPIApiService service

type ApiApplyApiKeyV2Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	body       *GetApiKeyRequest
}

// api.applyApiKey.implicit.value
func (r ApiApplyApiKeyV2Request) Body(body GetApiKeyRequest) ApiApplyApiKeyV2Request {
	r.body = &body
	return r
}

func (r ApiApplyApiKeyV2Request) Execute() (*GetApiKeyResponseV2, *http.Response, error) {
	return r.ApiService.ApplyApiKeyV2Execute(r)
}

/*
ApplyApiKeyV2 Update user's ApiKey

Change the ApiKey associated with the user's account. The current ApiKey must be provided as the value of the X-API-KEY HTTP header.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApplyApiKeyV2Request
*/
func (a *LoopringDEXRestfulAPIApiService) ApplyApiKeyV2(ctx context.Context) ApiApplyApiKeyV2Request {
	return ApiApplyApiKeyV2Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GetApiKeyResponseV2
func (a *LoopringDEXRestfulAPIApiService) ApplyApiKeyV2Execute(r ApiApplyApiKeyV2Request) (*GetApiKeyResponseV2, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetApiKeyResponseV2
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.ApplyApiKeyV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/apiKey"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApplyApiKeyV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	body       *GetApiKeyRequest
}

// api.applyApiKey.implicit.value
func (r ApiApplyApiKeyV3Request) Body(body GetApiKeyRequest) ApiApplyApiKeyV3Request {
	r.body = &body
	return r
}

func (r ApiApplyApiKeyV3Request) Execute() (*GetApiKeyResponseV3, *http.Response, error) {
	return r.ApiService.ApplyApiKeyV3Execute(r)
}

/*
ApplyApiKeyV3 Update user's ApiKey

Change the ApiKey associated with the user's account. The current ApiKey must be provided as the value of the X-API-KEY HTTP header.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApplyApiKeyV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) ApplyApiKeyV3(ctx context.Context) ApiApplyApiKeyV3Request {
	return ApiApplyApiKeyV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GetApiKeyResponseV3
func (a *LoopringDEXRestfulAPIApiService) ApplyApiKeyV3Execute(r ApiApplyApiKeyV3Request) (*GetApiKeyResponseV3, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetApiKeyResponseV3
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.ApplyApiKeyV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/apiKey"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBatchCancelOrdersByClientOrderIdV2Request struct {
	ctx           context.Context
	ApiService    *LoopringDEXRestfulAPIApiService
	accountId     *int32
	clientOrderId *string
}

// request.cancelOrders.accountId
func (r ApiBatchCancelOrdersByClientOrderIdV2Request) AccountId(accountId int32) ApiBatchCancelOrdersByClientOrderIdV2Request {
	r.accountId = &accountId
	return r
}

// ClientOrderIds of orders to be cancelled.
func (r ApiBatchCancelOrdersByClientOrderIdV2Request) ClientOrderId(clientOrderId string) ApiBatchCancelOrdersByClientOrderIdV2Request {
	r.clientOrderId = &clientOrderId
	return r
}

func (r ApiBatchCancelOrdersByClientOrderIdV2Request) Execute() (*BatchCancelOrderResponse, *http.Response, error) {
	return r.ApiService.BatchCancelOrdersByClientOrderIdV2Execute(r)
}

/*
BatchCancelOrdersByClientOrderIdV2 Cancel multiple orders by clientOrderId

Cancel up to 10 orders by clientOrderId.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBatchCancelOrdersByClientOrderIdV2Request
*/
func (a *LoopringDEXRestfulAPIApiService) BatchCancelOrdersByClientOrderIdV2(ctx context.Context) ApiBatchCancelOrdersByClientOrderIdV2Request {
	return ApiBatchCancelOrdersByClientOrderIdV2Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return BatchCancelOrderResponse
func (a *LoopringDEXRestfulAPIApiService) BatchCancelOrdersByClientOrderIdV2Execute(r ApiBatchCancelOrdersByClientOrderIdV2Request) (*BatchCancelOrderResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BatchCancelOrderResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.BatchCancelOrdersByClientOrderIdV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/orders/byClientOrderId"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.clientOrderId == nil {
		return localVarReturnValue, nil, reportError("clientOrderId is required and must be specified")
	}

	localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	localVarQueryParams.Add("clientOrderId", parameterToString(*r.clientOrderId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBatchCancelOrdersByClientOrderIdV3Request struct {
	ctx           context.Context
	ApiService    *LoopringDEXRestfulAPIApiService
	accountId     *int32
	clientOrderId *string
}

// request.cancelOrders.accountId
func (r ApiBatchCancelOrdersByClientOrderIdV3Request) AccountId(accountId int32) ApiBatchCancelOrdersByClientOrderIdV3Request {
	r.accountId = &accountId
	return r
}

// ClientOrderIds of orders to be cancelled.
func (r ApiBatchCancelOrdersByClientOrderIdV3Request) ClientOrderId(clientOrderId string) ApiBatchCancelOrdersByClientOrderIdV3Request {
	r.clientOrderId = &clientOrderId
	return r
}

func (r ApiBatchCancelOrdersByClientOrderIdV3Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.BatchCancelOrdersByClientOrderIdV3Execute(r)
}

/*
BatchCancelOrdersByClientOrderIdV3 Method for BatchCancelOrdersByClientOrderIdV3

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBatchCancelOrdersByClientOrderIdV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) BatchCancelOrdersByClientOrderIdV3(ctx context.Context) ApiBatchCancelOrdersByClientOrderIdV3Request {
	return ApiBatchCancelOrdersByClientOrderIdV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *LoopringDEXRestfulAPIApiService) BatchCancelOrdersByClientOrderIdV3Execute(r ApiBatchCancelOrdersByClientOrderIdV3Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.BatchCancelOrdersByClientOrderIdV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/orders/byClientOrderId"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.clientOrderId == nil {
		return localVarReturnValue, nil, reportError("clientOrderId is required and must be specified")
	}

	localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	localVarQueryParams.Add("clientOrderId", parameterToString(*r.clientOrderId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBatchCancelOrdersByOrderHashV2Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	accountId  *int32
	orderHash  *string
}

// request.cancelOrders.accountId
func (r ApiBatchCancelOrdersByOrderHashV2Request) AccountId(accountId int32) ApiBatchCancelOrdersByOrderHashV2Request {
	r.accountId = &accountId
	return r
}

// Hash of order to be canceled,separate multiple hashes with commas.
func (r ApiBatchCancelOrdersByOrderHashV2Request) OrderHash(orderHash string) ApiBatchCancelOrdersByOrderHashV2Request {
	r.orderHash = &orderHash
	return r
}

func (r ApiBatchCancelOrdersByOrderHashV2Request) Execute() (*BatchCancelOrderResponse, *http.Response, error) {
	return r.ApiService.BatchCancelOrdersByOrderHashV2Execute(r)
}

/*
BatchCancelOrdersByOrderHashV2 Cancel multiple orders by hash

Cancel up to 10 orders by order hash.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBatchCancelOrdersByOrderHashV2Request
*/
func (a *LoopringDEXRestfulAPIApiService) BatchCancelOrdersByOrderHashV2(ctx context.Context) ApiBatchCancelOrdersByOrderHashV2Request {
	return ApiBatchCancelOrdersByOrderHashV2Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return BatchCancelOrderResponse
func (a *LoopringDEXRestfulAPIApiService) BatchCancelOrdersByOrderHashV2Execute(r ApiBatchCancelOrdersByOrderHashV2Request) (*BatchCancelOrderResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BatchCancelOrderResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.BatchCancelOrdersByOrderHashV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/orders/byHash"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.orderHash == nil {
		return localVarReturnValue, nil, reportError("orderHash is required and must be specified")
	}

	localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	localVarQueryParams.Add("orderHash", parameterToString(*r.orderHash, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBatchCancelOrdersByOrderHashV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	accountId  *int32
	orderHash  *string
}

// request.cancelOrders.accountId
func (r ApiBatchCancelOrdersByOrderHashV3Request) AccountId(accountId int32) ApiBatchCancelOrdersByOrderHashV3Request {
	r.accountId = &accountId
	return r
}

// Hash of order to be canceled,separate multiple hashes with commas.
func (r ApiBatchCancelOrdersByOrderHashV3Request) OrderHash(orderHash string) ApiBatchCancelOrdersByOrderHashV3Request {
	r.orderHash = &orderHash
	return r
}

func (r ApiBatchCancelOrdersByOrderHashV3Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.BatchCancelOrdersByOrderHashV3Execute(r)
}

/*
BatchCancelOrdersByOrderHashV3 Method for BatchCancelOrdersByOrderHashV3

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBatchCancelOrdersByOrderHashV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) BatchCancelOrdersByOrderHashV3(ctx context.Context) ApiBatchCancelOrdersByOrderHashV3Request {
	return ApiBatchCancelOrdersByOrderHashV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *LoopringDEXRestfulAPIApiService) BatchCancelOrdersByOrderHashV3Execute(r ApiBatchCancelOrdersByOrderHashV3Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.BatchCancelOrdersByOrderHashV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/orders/byHash"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.orderHash == nil {
		return localVarReturnValue, nil, reportError("orderHash is required and must be specified")
	}

	localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	localVarQueryParams.Add("orderHash", parameterToString(*r.orderHash, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBatchSubmitOrderV2Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	body       *BatchSubmitOrderRequest
}

// Body of batch submit orders.
func (r ApiBatchSubmitOrderV2Request) Body(body BatchSubmitOrderRequest) ApiBatchSubmitOrderV2Request {
	r.body = &body
	return r
}

func (r ApiBatchSubmitOrderV2Request) Execute() (*BatchSubmitOrderResponse, *http.Response, error) {
	return r.ApiService.BatchSubmitOrderV2Execute(r)
}

/*
BatchSubmitOrderV2 Submit multiple orders

Submit up to 10 orders as a batch.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBatchSubmitOrderV2Request
*/
func (a *LoopringDEXRestfulAPIApiService) BatchSubmitOrderV2(ctx context.Context) ApiBatchSubmitOrderV2Request {
	return ApiBatchSubmitOrderV2Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return BatchSubmitOrderResponse
func (a *LoopringDEXRestfulAPIApiService) BatchSubmitOrderV2Execute(r ApiBatchSubmitOrderV2Request) (*BatchSubmitOrderResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BatchSubmitOrderResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.BatchSubmitOrderV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/batchOrders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCanMintV3Request struct {
	ctx             context.Context
	ApiService      *LoopringDEXRestfulAPIApiService
	minter          *string
	nftTokenAddress *string
}

// minter address
func (r ApiCanMintV3Request) Minter(minter string) ApiCanMintV3Request {
	r.minter = &minter
	return r
}

// nft token address
func (r ApiCanMintV3Request) NftTokenAddress(nftTokenAddress string) ApiCanMintV3Request {
	r.nftTokenAddress = &nftTokenAddress
	return r
}

func (r ApiCanMintV3Request) Execute() (bool, *http.Response, error) {
	return r.ApiService.CanMintV3Execute(r)
}

/*
CanMintV3 check if a minter is authorized on a nft token contract

true if authorized, false otherwise.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCanMintV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) CanMintV3(ctx context.Context) ApiCanMintV3Request {
	return ApiCanMintV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return bool
func (a *LoopringDEXRestfulAPIApiService) CanMintV3Execute(r ApiCanMintV3Request) (bool, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue bool
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.CanMintV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/nft/info/canMint"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.minter == nil {
		return localVarReturnValue, nil, reportError("minter is required and must be specified")
	}
	if r.nftTokenAddress == nil {
		return localVarReturnValue, nil, reportError("nftTokenAddress is required and must be specified")
	}

	localVarQueryParams.Add("minter", parameterToString(*r.minter, ""))
	localVarQueryParams.Add("nftTokenAddress", parameterToString(*r.nftTokenAddress, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCancelOrderV3Request struct {
	ctx           context.Context
	ApiService    *LoopringDEXRestfulAPIApiService
	accountId     *int64
	orderHash     *string
	clientOrderId *string
}

// Account ID
func (r ApiCancelOrderV3Request) AccountId(accountId int64) ApiCancelOrderV3Request {
	r.accountId = &accountId
	return r
}

// Order HASH
func (r ApiCancelOrderV3Request) OrderHash(orderHash string) ApiCancelOrderV3Request {
	r.orderHash = &orderHash
	return r
}

// The unique order ID of the client
func (r ApiCancelOrderV3Request) ClientOrderId(clientOrderId string) ApiCancelOrderV3Request {
	r.clientOrderId = &clientOrderId
	return r
}

func (r ApiCancelOrderV3Request) Execute() (*SubmitOrderResponseItemV3, *http.Response, error) {
	return r.ApiService.CancelOrderV3Execute(r)
}

/*
CancelOrderV3 Cancel order

Cancel order using order hash or client-side ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCancelOrderV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) CancelOrderV3(ctx context.Context) ApiCancelOrderV3Request {
	return ApiCancelOrderV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return SubmitOrderResponseItemV3
func (a *LoopringDEXRestfulAPIApiService) CancelOrderV3Execute(r ApiCancelOrderV3Request) (*SubmitOrderResponseItemV3, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SubmitOrderResponseItemV3
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.CancelOrderV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}

	localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	if r.orderHash != nil {
		localVarQueryParams.Add("orderHash", parameterToString(*r.orderHash, ""))
	}
	if r.clientOrderId != nil {
		localVarQueryParams.Add("clientOrderId", parameterToString(*r.clientOrderId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCancelOrdersV2Request struct {
	ctx           context.Context
	ApiService    *LoopringDEXRestfulAPIApiService
	accountId     *int64
	orderHash     *string
	clientOrderId *string
}

// request.cancelOrders.accountId
func (r ApiCancelOrdersV2Request) AccountId(accountId int64) ApiCancelOrdersV2Request {
	r.accountId = &accountId
	return r
}

// request.cancelOrders.orderHash
func (r ApiCancelOrdersV2Request) OrderHash(orderHash string) ApiCancelOrdersV2Request {
	r.orderHash = &orderHash
	return r
}

// request.cancelOrders.clientOrderId
func (r ApiCancelOrdersV2Request) ClientOrderId(clientOrderId string) ApiCancelOrdersV2Request {
	r.clientOrderId = &clientOrderId
	return r
}

func (r ApiCancelOrdersV2Request) Execute() (*CancelOrdersResponseData, *http.Response, error) {
	return r.ApiService.CancelOrdersV2Execute(r)
}

/*
CancelOrdersV2 api.CancelOrders.value

api.CancelOrders.notes

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCancelOrdersV2Request
*/
func (a *LoopringDEXRestfulAPIApiService) CancelOrdersV2(ctx context.Context) ApiCancelOrdersV2Request {
	return ApiCancelOrdersV2Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return CancelOrdersResponseData
func (a *LoopringDEXRestfulAPIApiService) CancelOrdersV2Execute(r ApiCancelOrdersV2Request) (*CancelOrdersResponseData, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CancelOrdersResponseData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.CancelOrdersV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/orders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}

	localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	if r.orderHash != nil {
		localVarQueryParams.Add("orderHash", parameterToString(*r.orderHash, ""))
	}
	if r.clientOrderId != nil {
		localVarQueryParams.Add("clientOrderId", parameterToString(*r.clientOrderId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiClaimLuckyTokenV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	body       *ClaimLuckyTokenRequestV3
}

// api.claimLuckyToken.implicit.value
func (r ApiClaimLuckyTokenV3Request) Body(body ClaimLuckyTokenRequestV3) ApiClaimLuckyTokenV3Request {
	r.body = &body
	return r
}

func (r ApiClaimLuckyTokenV3Request) Execute() (*GetLuckyTokenClaimAmountResponse, *http.Response, error) {
	return r.ApiService.ClaimLuckyTokenV3Execute(r)
}

/*
ClaimLuckyTokenV3 api.claimLuckyToken.value

api.claimLuckyToken.notes

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiClaimLuckyTokenV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) ClaimLuckyTokenV3(ctx context.Context) ApiClaimLuckyTokenV3Request {
	return ApiClaimLuckyTokenV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GetLuckyTokenClaimAmountResponse
func (a *LoopringDEXRestfulAPIApiService) ClaimLuckyTokenV3Execute(r ApiClaimLuckyTokenV3Request) (*GetLuckyTokenClaimAmountResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetLuckyTokenClaimAmountResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.ClaimLuckyTokenV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/luckyToken/claimLuckyToken"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiComputeTokenAddressV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	nftFactory *string
	nftOwner   *string
	nftBaseUri *string
}

func (r ApiComputeTokenAddressV3Request) NftFactory(nftFactory string) ApiComputeTokenAddressV3Request {
	r.nftFactory = &nftFactory
	return r
}

func (r ApiComputeTokenAddressV3Request) NftOwner(nftOwner string) ApiComputeTokenAddressV3Request {
	r.nftOwner = &nftOwner
	return r
}

// request.computeTokenAddress.nftBaseUri
func (r ApiComputeTokenAddressV3Request) NftBaseUri(nftBaseUri string) ApiComputeTokenAddressV3Request {
	r.nftBaseUri = &nftBaseUri
	return r
}

func (r ApiComputeTokenAddressV3Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ComputeTokenAddressV3Execute(r)
}

/*
ComputeTokenAddressV3 Method for ComputeTokenAddressV3

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiComputeTokenAddressV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) ComputeTokenAddressV3(ctx context.Context) ApiComputeTokenAddressV3Request {
	return ApiComputeTokenAddressV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *LoopringDEXRestfulAPIApiService) ComputeTokenAddressV3Execute(r ApiComputeTokenAddressV3Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.ComputeTokenAddressV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/nft/info/computeTokenAddress"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.nftFactory != nil {
		localVarQueryParams.Add("nftFactory", parameterToString(*r.nftFactory, ""))
	}
	if r.nftOwner != nil {
		localVarQueryParams.Add("nftOwner", parameterToString(*r.nftOwner, ""))
	}
	if r.nftBaseUri != nil {
		localVarQueryParams.Add("nftBaseUri", parameterToString(*r.nftBaseUri, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConfirmHebaoPayV3HebaoRequest struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
}

func (r ApiConfirmHebaoPayV3HebaoRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ConfirmHebaoPayV3HebaoExecute(r)
}

/*
ConfirmHebaoPayV3Hebao Method for ConfirmHebaoPayV3Hebao

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiConfirmHebaoPayV3HebaoRequest
*/
func (a *LoopringDEXRestfulAPIApiService) ConfirmHebaoPayV3Hebao(ctx context.Context) ApiConfirmHebaoPayV3HebaoRequest {
	return ApiConfirmHebaoPayV3HebaoRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *LoopringDEXRestfulAPIApiService) ConfirmHebaoPayV3HebaoExecute(r ApiConfirmHebaoPayV3HebaoRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.ConfirmHebaoPayV3Hebao")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/hebao/confirmPay"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCrawlPriceFromBinanceV2Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
}

func (r ApiCrawlPriceFromBinanceV2Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.CrawlPriceFromBinanceV2Execute(r)
}

/*
CrawlPriceFromBinanceV2 Method for CrawlPriceFromBinanceV2

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCrawlPriceFromBinanceV2Request
*/
func (a *LoopringDEXRestfulAPIApiService) CrawlPriceFromBinanceV2(ctx context.Context) ApiCrawlPriceFromBinanceV2Request {
	return ApiCrawlPriceFromBinanceV2Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *LoopringDEXRestfulAPIApiService) CrawlPriceFromBinanceV2Execute(r ApiCrawlPriceFromBinanceV2Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.CrawlPriceFromBinanceV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/crawlPriceFromBinance"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCrawlSiteV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	site       *string
}

func (r ApiCrawlSiteV3Request) Site(site string) ApiCrawlSiteV3Request {
	r.site = &site
	return r
}

func (r ApiCrawlSiteV3Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.CrawlSiteV3Execute(r)
}

/*
CrawlSiteV3 Method for CrawlSiteV3

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCrawlSiteV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) CrawlSiteV3(ctx context.Context) ApiCrawlSiteV3Request {
	return ApiCrawlSiteV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *LoopringDEXRestfulAPIApiService) CrawlSiteV3Execute(r ApiCrawlSiteV3Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.CrawlSiteV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/crawl"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.site != nil {
		localVarQueryParams.Add("site", parameterToString(*r.site, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeployTokenAddressV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
}

func (r ApiDeployTokenAddressV3Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DeployTokenAddressV3Execute(r)
}

/*
DeployTokenAddressV3 Method for DeployTokenAddressV3

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeployTokenAddressV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) DeployTokenAddressV3(ctx context.Context) ApiDeployTokenAddressV3Request {
	return ApiDeployTokenAddressV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *LoopringDEXRestfulAPIApiService) DeployTokenAddressV3Execute(r ApiDeployTokenAddressV3Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.DeployTokenAddressV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/nft/deployTokenAddress"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAccountServicesV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	phone      *string
	email      *string
	wallet     *string
}

func (r ApiGetAccountServicesV3Request) Phone(phone string) ApiGetAccountServicesV3Request {
	r.phone = &phone
	return r
}

func (r ApiGetAccountServicesV3Request) Email(email string) ApiGetAccountServicesV3Request {
	r.email = &email
	return r
}

func (r ApiGetAccountServicesV3Request) Wallet(wallet string) ApiGetAccountServicesV3Request {
	r.wallet = &wallet
	return r
}

func (r ApiGetAccountServicesV3Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetAccountServicesV3Execute(r)
}

/*
GetAccountServicesV3 Method for GetAccountServicesV3

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAccountServicesV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetAccountServicesV3(ctx context.Context) ApiGetAccountServicesV3Request {
	return ApiGetAccountServicesV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *LoopringDEXRestfulAPIApiService) GetAccountServicesV3Execute(r ApiGetAccountServicesV3Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetAccountServicesV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/spi/getAccountServices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.phone != nil {
		localVarQueryParams.Add("phone", parameterToString(*r.phone, ""))
	}
	if r.email != nil {
		localVarQueryParams.Add("email", parameterToString(*r.email, ""))
	}
	if r.wallet != nil {
		localVarQueryParams.Add("wallet", parameterToString(*r.wallet, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAccountV2Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	owner      *string
}

// Ethereum address
func (r ApiGetAccountV2Request) Owner(owner string) ApiGetAccountV2Request {
	r.owner = &owner
	return r
}

func (r ApiGetAccountV2Request) Execute() (*GetAccountResponseV2, *http.Response, error) {
	return r.ApiService.GetAccountV2Execute(r)
}

/*
GetAccountV2 Query user information

Returns data associated with the user's exchange account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAccountV2Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetAccountV2(ctx context.Context) ApiGetAccountV2Request {
	return ApiGetAccountV2Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GetAccountResponseV2
func (a *LoopringDEXRestfulAPIApiService) GetAccountV2Execute(r ApiGetAccountV2Request) (*GetAccountResponseV2, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetAccountResponseV2
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetAccountV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/account"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.owner == nil {
		return localVarReturnValue, nil, reportError("owner is required and must be specified")
	}

	localVarQueryParams.Add("owner", parameterToString(*r.owner, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAccountV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	owner      *string
	accountId  *int64
}

// Ethereum address, either owner or accountId should be presented.
func (r ApiGetAccountV3Request) Owner(owner string) ApiGetAccountV3Request {
	r.owner = &owner
	return r
}

// AccountID, if owner is presented, it must be align with the owners accountId, otherwise an error occurs.
func (r ApiGetAccountV3Request) AccountId(accountId int64) ApiGetAccountV3Request {
	r.accountId = &accountId
	return r
}

func (r ApiGetAccountV3Request) Execute() (*DexAccountV3, *http.Response, error) {
	return r.ApiService.GetAccountV3Execute(r)
}

/*
GetAccountV3 Query user information

Returns data associated with the user's exchange account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAccountV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetAccountV3(ctx context.Context) ApiGetAccountV3Request {
	return ApiGetAccountV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return DexAccountV3
func (a *LoopringDEXRestfulAPIApiService) GetAccountV3Execute(r ApiGetAccountV3Request) (*DexAccountV3, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DexAccountV3
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetAccountV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/account"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.owner != nil {
		localVarQueryParams.Add("owner", parameterToString(*r.owner, ""))
	}
	if r.accountId != nil {
		localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetActivityRulesV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
}

func (r ApiGetActivityRulesV3Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetActivityRulesV3Execute(r)
}

/*
GetActivityRulesV3 Method for GetActivityRulesV3

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetActivityRulesV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetActivityRulesV3(ctx context.Context) ApiGetActivityRulesV3Request {
	return ApiGetActivityRulesV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *LoopringDEXRestfulAPIApiService) GetActivityRulesV3Execute(r ApiGetActivityRulesV3Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetActivityRulesV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/sidecar/activityRules"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAllowanceV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	owner      *string
	token      *string
}

// Ethereum address
func (r ApiGetAllowanceV3Request) Owner(owner string) ApiGetAllowanceV3Request {
	r.owner = &owner
	return r
}

// The token address to query
func (r ApiGetAllowanceV3Request) Token(token string) ApiGetAllowanceV3Request {
	r.token = &token
	return r
}

func (r ApiGetAllowanceV3Request) Execute() (*GetAllowancesV2Response, *http.Response, error) {
	return r.ApiService.GetAllowanceV3Execute(r)
}

/*
GetAllowanceV3 Get user token allowance

Returns the allowance of a given token that the user has authorized for Loopring.io

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAllowanceV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetAllowanceV3(ctx context.Context) ApiGetAllowanceV3Request {
	return ApiGetAllowanceV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GetAllowancesV2Response
func (a *LoopringDEXRestfulAPIApiService) GetAllowanceV3Execute(r ApiGetAllowanceV3Request) (*GetAllowancesV2Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetAllowancesV2Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetAllowanceV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/eth/allowances"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.owner == nil {
		return localVarReturnValue, nil, reportError("owner is required and must be specified")
	}
	if r.token == nil {
		return localVarReturnValue, nil, reportError("token is required and must be specified")
	}

	localVarQueryParams.Add("owner", parameterToString(*r.owner, ""))
	localVarQueryParams.Add("token", parameterToString(*r.token, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAmmAssetsV3Request struct {
	ctx         context.Context
	ApiService  *LoopringDEXRestfulAPIApiService
	poolAddress *string
	limit       *int32
}

func (r ApiGetAmmAssetsV3Request) PoolAddress(poolAddress string) ApiGetAmmAssetsV3Request {
	r.poolAddress = &poolAddress
	return r
}

func (r ApiGetAmmAssetsV3Request) Limit(limit int32) ApiGetAmmAssetsV3Request {
	r.limit = &limit
	return r
}

func (r ApiGetAmmAssetsV3Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetAmmAssetsV3Execute(r)
}

/*
GetAmmAssetsV3 Method for GetAmmAssetsV3

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAmmAssetsV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetAmmAssetsV3(ctx context.Context) ApiGetAmmAssetsV3Request {
	return ApiGetAmmAssetsV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *LoopringDEXRestfulAPIApiService) GetAmmAssetsV3Execute(r ApiGetAmmAssetsV3Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetAmmAssetsV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/amm/assets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.poolAddress != nil {
		localVarQueryParams.Add("poolAddress", parameterToString(*r.poolAddress, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAmmDepthV2Request struct {
	ctx         context.Context
	ApiService  *LoopringDEXRestfulAPIApiService
	poolAddress *string
	level       *int32
	limit       *int32
}

// request.getAmmDepth.market
func (r ApiGetAmmDepthV2Request) PoolAddress(poolAddress string) ApiGetAmmDepthV2Request {
	r.poolAddress = &poolAddress
	return r
}

// Order book aggregation level, larger value means further price aggregation.
func (r ApiGetAmmDepthV2Request) Level(level int32) ApiGetAmmDepthV2Request {
	r.level = &level
	return r
}

// Maximum numbers of bids/asks.
func (r ApiGetAmmDepthV2Request) Limit(limit int32) ApiGetAmmDepthV2Request {
	r.limit = &limit
	return r
}

func (r ApiGetAmmDepthV2Request) Execute() (*GetDepthResponseV2, *http.Response, error) {
	return r.ApiService.GetAmmDepthV2Execute(r)
}

/*
GetAmmDepthV2 Get market orderbook

Returns the order book of a given trading pair.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAmmDepthV2Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetAmmDepthV2(ctx context.Context) ApiGetAmmDepthV2Request {
	return ApiGetAmmDepthV2Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GetDepthResponseV2
func (a *LoopringDEXRestfulAPIApiService) GetAmmDepthV2Execute(r ApiGetAmmDepthV2Request) (*GetDepthResponseV2, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetDepthResponseV2
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetAmmDepthV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/amm/depth"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.poolAddress == nil {
		return localVarReturnValue, nil, reportError("poolAddress is required and must be specified")
	}
	if r.level == nil {
		return localVarReturnValue, nil, reportError("level is required and must be specified")
	}

	localVarQueryParams.Add("poolAddress", parameterToString(*r.poolAddress, ""))
	localVarQueryParams.Add("level", parameterToString(*r.level, ""))
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAmmDepthV3Request struct {
	ctx         context.Context
	ApiService  *LoopringDEXRestfulAPIApiService
	poolAddress *string
	level       *int32
	limit       *int32
}

// request.getAmmDepth.market
func (r ApiGetAmmDepthV3Request) PoolAddress(poolAddress string) ApiGetAmmDepthV3Request {
	r.poolAddress = &poolAddress
	return r
}

// Order book aggregation level, larger value means further price aggregation.
func (r ApiGetAmmDepthV3Request) Level(level int32) ApiGetAmmDepthV3Request {
	r.level = &level
	return r
}

// Maximum numbers of bids/asks.
func (r ApiGetAmmDepthV3Request) Limit(limit int32) ApiGetAmmDepthV3Request {
	r.limit = &limit
	return r
}

func (r ApiGetAmmDepthV3Request) Execute() (*DepthV3, *http.Response, error) {
	return r.ApiService.GetAmmDepthV3Execute(r)
}

/*
GetAmmDepthV3 Get market orderbook

Returns the order book of a given trading pair.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAmmDepthV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetAmmDepthV3(ctx context.Context) ApiGetAmmDepthV3Request {
	return ApiGetAmmDepthV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return DepthV3
func (a *LoopringDEXRestfulAPIApiService) GetAmmDepthV3Execute(r ApiGetAmmDepthV3Request) (*DepthV3, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DepthV3
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetAmmDepthV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/amm/depth"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.poolAddress == nil {
		return localVarReturnValue, nil, reportError("poolAddress is required and must be specified")
	}
	if r.level == nil {
		return localVarReturnValue, nil, reportError("level is required and must be specified")
	}

	localVarQueryParams.Add("poolAddress", parameterToString(*r.poolAddress, ""))
	localVarQueryParams.Add("level", parameterToString(*r.level, ""))
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAmmMarketsV2Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
}

func (r ApiGetAmmMarketsV2Request) Execute() (*GetAmmMarketInfoResponse, *http.Response, error) {
	return r.ApiService.GetAmmMarketsV2Execute(r)
}

/*
GetAmmMarketsV2 api.getAmmMarkets.value

api.getAmmMarkets.notes

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAmmMarketsV2Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetAmmMarketsV2(ctx context.Context) ApiGetAmmMarketsV2Request {
	return ApiGetAmmMarketsV2Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GetAmmMarketInfoResponse
func (a *LoopringDEXRestfulAPIApiService) GetAmmMarketsV2Execute(r ApiGetAmmMarketsV2Request) (*GetAmmMarketInfoResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetAmmMarketInfoResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetAmmMarketsV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/amm/markets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAmmPoolBalanceV3Request struct {
	ctx         context.Context
	ApiService  *LoopringDEXRestfulAPIApiService
	poolAddress *string
}

// input AMM pool address
func (r ApiGetAmmPoolBalanceV3Request) PoolAddress(poolAddress string) ApiGetAmmPoolBalanceV3Request {
	r.poolAddress = &poolAddress
	return r
}

func (r ApiGetAmmPoolBalanceV3Request) Execute() (*AmmPoolBalanceV3, *http.Response, error) {
	return r.ApiService.GetAmmPoolBalanceV3Execute(r)
}

/*
GetAmmPoolBalanceV3 Get AMM pool balance snapshot

Returns the snapshot of specific AMM pool

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAmmPoolBalanceV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetAmmPoolBalanceV3(ctx context.Context) ApiGetAmmPoolBalanceV3Request {
	return ApiGetAmmPoolBalanceV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return AmmPoolBalanceV3
func (a *LoopringDEXRestfulAPIApiService) GetAmmPoolBalanceV3Execute(r ApiGetAmmPoolBalanceV3Request) (*AmmPoolBalanceV3, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AmmPoolBalanceV3
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetAmmPoolBalanceV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/amm/balance"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.poolAddress == nil {
		return localVarReturnValue, nil, reportError("poolAddress is required and must be specified")
	}

	localVarQueryParams.Add("poolAddress", parameterToString(*r.poolAddress, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAmmPoolsBalancesV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
}

func (r ApiGetAmmPoolsBalancesV3Request) Execute() (*AmmPoolBalanceV3, *http.Response, error) {
	return r.ApiService.GetAmmPoolsBalancesV3Execute(r)
}

/*
GetAmmPoolsBalancesV3 api.getAmmPoolsBalances.value

api.getAmmPoolsBalances.notes

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAmmPoolsBalancesV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetAmmPoolsBalancesV3(ctx context.Context) ApiGetAmmPoolsBalancesV3Request {
	return ApiGetAmmPoolsBalancesV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return AmmPoolBalanceV3
func (a *LoopringDEXRestfulAPIApiService) GetAmmPoolsBalancesV3Execute(r ApiGetAmmPoolsBalancesV3Request) (*AmmPoolBalanceV3, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AmmPoolBalanceV3
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetAmmPoolsBalancesV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/amm/balances"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAmmPoolsV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
}

func (r ApiGetAmmPoolsV3Request) Execute() (*GetAmmPoolsResponse, *http.Response, error) {
	return r.ApiService.GetAmmPoolsV3Execute(r)
}

/*
GetAmmPoolsV3 Get AMM pool configurations

Returns the configurations of all supported AMM pools

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAmmPoolsV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetAmmPoolsV3(ctx context.Context) ApiGetAmmPoolsV3Request {
	return ApiGetAmmPoolsV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GetAmmPoolsResponse
func (a *LoopringDEXRestfulAPIApiService) GetAmmPoolsV3Execute(r ApiGetAmmPoolsV3Request) (*GetAmmPoolsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetAmmPoolsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetAmmPoolsV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/amm/pools"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAmmSnapshotV2Request struct {
	ctx         context.Context
	ApiService  *LoopringDEXRestfulAPIApiService
	poolAddress *string
}

// request.getAmmSnapshot.address
func (r ApiGetAmmSnapshotV2Request) PoolAddress(poolAddress string) ApiGetAmmSnapshotV2Request {
	r.poolAddress = &poolAddress
	return r
}

func (r ApiGetAmmSnapshotV2Request) Execute() (*GetAmmSnapshotResponse, *http.Response, error) {
	return r.ApiService.GetAmmSnapshotV2Execute(r)
}

/*
GetAmmSnapshotV2 api.getAmmSnapshot.value

api.getAmmSnapshot.notes

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAmmSnapshotV2Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetAmmSnapshotV2(ctx context.Context) ApiGetAmmSnapshotV2Request {
	return ApiGetAmmSnapshotV2Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GetAmmSnapshotResponse
func (a *LoopringDEXRestfulAPIApiService) GetAmmSnapshotV2Execute(r ApiGetAmmSnapshotV2Request) (*GetAmmSnapshotResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetAmmSnapshotResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetAmmSnapshotV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/amm/snapshot"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.poolAddress == nil {
		return localVarReturnValue, nil, reportError("poolAddress is required and must be specified")
	}

	localVarQueryParams.Add("poolAddress", parameterToString(*r.poolAddress, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAmmSnapshotsV2Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
}

func (r ApiGetAmmSnapshotsV2Request) Execute() (*GetAmmSnapshotResponse, *http.Response, error) {
	return r.ApiService.GetAmmSnapshotsV2Execute(r)
}

/*
GetAmmSnapshotsV2 api.getAmmSnapshots.value

api.getAmmSnapshots.notes

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAmmSnapshotsV2Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetAmmSnapshotsV2(ctx context.Context) ApiGetAmmSnapshotsV2Request {
	return ApiGetAmmSnapshotsV2Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GetAmmSnapshotResponse
func (a *LoopringDEXRestfulAPIApiService) GetAmmSnapshotsV2Execute(r ApiGetAmmSnapshotsV2Request) (*GetAmmSnapshotResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetAmmSnapshotResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetAmmSnapshotsV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/amm/snapshots"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAmmTradesV2Request struct {
	ctx            context.Context
	ApiService     *LoopringDEXRestfulAPIApiService
	ammPoolAddress *string
	limit          *int32
	offset         *int64
}

func (r ApiGetAmmTradesV2Request) AmmPoolAddress(ammPoolAddress string) ApiGetAmmTradesV2Request {
	r.ammPoolAddress = &ammPoolAddress
	return r
}

func (r ApiGetAmmTradesV2Request) Limit(limit int32) ApiGetAmmTradesV2Request {
	r.limit = &limit
	return r
}

func (r ApiGetAmmTradesV2Request) Offset(offset int64) ApiGetAmmTradesV2Request {
	r.offset = &offset
	return r
}

func (r ApiGetAmmTradesV2Request) Execute() (*GetAmmTradesResponseV2, *http.Response, error) {
	return r.ApiService.GetAmmTradesV2Execute(r)
}

/*
GetAmmTradesV2 get AMM pool trade transactions

get AMM pool trade transactions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAmmTradesV2Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetAmmTradesV2(ctx context.Context) ApiGetAmmTradesV2Request {
	return ApiGetAmmTradesV2Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GetAmmTradesResponseV2
func (a *LoopringDEXRestfulAPIApiService) GetAmmTradesV2Execute(r ApiGetAmmTradesV2Request) (*GetAmmTradesResponseV2, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetAmmTradesResponseV2
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetAmmTradesV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/amm/trades"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ammPoolAddress != nil {
		localVarQueryParams.Add("ammPoolAddress", parameterToString(*r.ammPoolAddress, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAmmTradesV3Request struct {
	ctx            context.Context
	ApiService     *LoopringDEXRestfulAPIApiService
	ammPoolAddress *string
	limit          *int32
	offset         *int64
}

// The address of the pool on which the swap was submitted.
func (r ApiGetAmmTradesV3Request) AmmPoolAddress(ammPoolAddress string) ApiGetAmmTradesV3Request {
	r.ammPoolAddress = &ammPoolAddress
	return r
}

// Used to limit the number of returned records. Useful in implementing pagination.
func (r ApiGetAmmTradesV3Request) Limit(limit int32) ApiGetAmmTradesV3Request {
	r.limit = &limit
	return r
}

// Used to apply an offset when looking for valid records. Useful in implementing
func (r ApiGetAmmTradesV3Request) Offset(offset int64) ApiGetAmmTradesV3Request {
	r.offset = &offset
	return r
}

func (r ApiGetAmmTradesV3Request) Execute() (*AmmTradeDataListV3, *http.Response, error) {
	return r.ApiService.GetAmmTradesV3Execute(r)
}

/*
GetAmmTradesV3 get AMM pool trade transactions

get AMM pool trade transactions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAmmTradesV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetAmmTradesV3(ctx context.Context) ApiGetAmmTradesV3Request {
	return ApiGetAmmTradesV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return AmmTradeDataListV3
func (a *LoopringDEXRestfulAPIApiService) GetAmmTradesV3Execute(r ApiGetAmmTradesV3Request) (*AmmTradeDataListV3, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AmmTradeDataListV3
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetAmmTradesV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/amm/trades"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ammPoolAddress == nil {
		return localVarReturnValue, nil, reportError("ammPoolAddress is required and must be specified")
	}

	localVarQueryParams.Add("ammPoolAddress", parameterToString(*r.ammPoolAddress, ""))
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAmmTransactionsV2Request struct {
	ctx             context.Context
	ApiService      *LoopringDEXRestfulAPIApiService
	poolAddress     *string
	billType        *int32
	start           *int64
	end             *int64
	limit           *int32
	offset          *int32
	tokenId         *int32
	income          *bool
	transferAddress *string
	fromAddress     *string
}

func (r ApiGetAmmTransactionsV2Request) PoolAddress(poolAddress string) ApiGetAmmTransactionsV2Request {
	r.poolAddress = &poolAddress
	return r
}

func (r ApiGetAmmTransactionsV2Request) BillType(billType int32) ApiGetAmmTransactionsV2Request {
	r.billType = &billType
	return r
}

func (r ApiGetAmmTransactionsV2Request) Start(start int64) ApiGetAmmTransactionsV2Request {
	r.start = &start
	return r
}

func (r ApiGetAmmTransactionsV2Request) End(end int64) ApiGetAmmTransactionsV2Request {
	r.end = &end
	return r
}

func (r ApiGetAmmTransactionsV2Request) Limit(limit int32) ApiGetAmmTransactionsV2Request {
	r.limit = &limit
	return r
}

func (r ApiGetAmmTransactionsV2Request) Offset(offset int32) ApiGetAmmTransactionsV2Request {
	r.offset = &offset
	return r
}

func (r ApiGetAmmTransactionsV2Request) TokenId(tokenId int32) ApiGetAmmTransactionsV2Request {
	r.tokenId = &tokenId
	return r
}

func (r ApiGetAmmTransactionsV2Request) Income(income bool) ApiGetAmmTransactionsV2Request {
	r.income = &income
	return r
}

func (r ApiGetAmmTransactionsV2Request) TransferAddress(transferAddress string) ApiGetAmmTransactionsV2Request {
	r.transferAddress = &transferAddress
	return r
}

func (r ApiGetAmmTransactionsV2Request) FromAddress(fromAddress string) ApiGetAmmTransactionsV2Request {
	r.fromAddress = &fromAddress
	return r
}

func (r ApiGetAmmTransactionsV2Request) Execute() (*GetAmmTransactionResponseV2, *http.Response, error) {
	return r.ApiService.GetAmmTransactionsV2Execute(r)
}

/*
GetAmmTransactionsV2 get AMM involved join/exit transactions

Return the AMM join/exit transactions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAmmTransactionsV2Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetAmmTransactionsV2(ctx context.Context) ApiGetAmmTransactionsV2Request {
	return ApiGetAmmTransactionsV2Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GetAmmTransactionResponseV2
func (a *LoopringDEXRestfulAPIApiService) GetAmmTransactionsV2Execute(r ApiGetAmmTransactionsV2Request) (*GetAmmTransactionResponseV2, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetAmmTransactionResponseV2
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetAmmTransactionsV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/amm/transactions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.poolAddress != nil {
		localVarQueryParams.Add("poolAddress", parameterToString(*r.poolAddress, ""))
	}
	if r.billType != nil {
		localVarQueryParams.Add("billType", parameterToString(*r.billType, ""))
	}
	if r.start != nil {
		localVarQueryParams.Add("start", parameterToString(*r.start, ""))
	}
	if r.end != nil {
		localVarQueryParams.Add("end", parameterToString(*r.end, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.tokenId != nil {
		localVarQueryParams.Add("tokenId", parameterToString(*r.tokenId, ""))
	}
	if r.income != nil {
		localVarQueryParams.Add("income", parameterToString(*r.income, ""))
	}
	if r.transferAddress != nil {
		localVarQueryParams.Add("transferAddress", parameterToString(*r.transferAddress, ""))
	}
	if r.fromAddress != nil {
		localVarQueryParams.Add("fromAddress", parameterToString(*r.fromAddress, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAmmTransactionsV3Request struct {
	ctx         context.Context
	ApiService  *LoopringDEXRestfulAPIApiService
	poolAddress *string
	start       *int64
	end         *int64
	limit       *int32
	offset      *int64
	txTypes     *string
	txStatus    *string
}

// The address of the pool on which the swap was submitted.
func (r ApiGetAmmTransactionsV3Request) PoolAddress(poolAddress string) ApiGetAmmTransactionsV3Request {
	r.poolAddress = &poolAddress
	return r
}

// Date from which to start fetching AMM transactions.
func (r ApiGetAmmTransactionsV3Request) Start(start int64) ApiGetAmmTransactionsV3Request {
	r.start = &start
	return r
}

// End Date of the query
func (r ApiGetAmmTransactionsV3Request) End(end int64) ApiGetAmmTransactionsV3Request {
	r.end = &end
	return r
}

// Used to limit the number of returned records. Useful in implementing pagination.
func (r ApiGetAmmTransactionsV3Request) Limit(limit int32) ApiGetAmmTransactionsV3Request {
	r.limit = &limit
	return r
}

// Used to apply an offset when looking for valid records. Useful in implementing
func (r ApiGetAmmTransactionsV3Request) Offset(offset int64) ApiGetAmmTransactionsV3Request {
	r.offset = &offset
	return r
}

// Transaction type: join or exit
func (r ApiGetAmmTransactionsV3Request) TxTypes(txTypes string) ApiGetAmmTransactionsV3Request {
	r.txTypes = &txTypes
	return r
}

// The AMM transaction status.
func (r ApiGetAmmTransactionsV3Request) TxStatus(txStatus string) ApiGetAmmTransactionsV3Request {
	r.txStatus = &txStatus
	return r
}

func (r ApiGetAmmTransactionsV3Request) Execute() (*UserBillList, *http.Response, error) {
	return r.ApiService.GetAmmTransactionsV3Execute(r)
}

/*
GetAmmTransactionsV3 get AMM involved join/exit transactions

Return the AMM join/exit transactions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAmmTransactionsV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetAmmTransactionsV3(ctx context.Context) ApiGetAmmTransactionsV3Request {
	return ApiGetAmmTransactionsV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return UserBillList
func (a *LoopringDEXRestfulAPIApiService) GetAmmTransactionsV3Execute(r ApiGetAmmTransactionsV3Request) (*UserBillList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UserBillList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetAmmTransactionsV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/amm/transactions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.poolAddress == nil {
		return localVarReturnValue, nil, reportError("poolAddress is required and must be specified")
	}

	localVarQueryParams.Add("poolAddress", parameterToString(*r.poolAddress, ""))
	if r.start != nil {
		localVarQueryParams.Add("start", parameterToString(*r.start, ""))
	}
	if r.end != nil {
		localVarQueryParams.Add("end", parameterToString(*r.end, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.txTypes != nil {
		localVarQueryParams.Add("txTypes", parameterToString(*r.txTypes, ""))
	}
	if r.txStatus != nil {
		localVarQueryParams.Add("txStatus", parameterToString(*r.txStatus, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAmmUserTransactionsV2Request struct {
	ctx            context.Context
	ApiService     *LoopringDEXRestfulAPIApiService
	accountId      *int64
	start          *int64
	end            *int64
	limit          *int32
	offset         *int64
	txTypes        *string
	txStatus       *string
	ammPoolAddress *string
}

func (r ApiGetAmmUserTransactionsV2Request) AccountId(accountId int64) ApiGetAmmUserTransactionsV2Request {
	r.accountId = &accountId
	return r
}

func (r ApiGetAmmUserTransactionsV2Request) Start(start int64) ApiGetAmmUserTransactionsV2Request {
	r.start = &start
	return r
}

func (r ApiGetAmmUserTransactionsV2Request) End(end int64) ApiGetAmmUserTransactionsV2Request {
	r.end = &end
	return r
}

func (r ApiGetAmmUserTransactionsV2Request) Limit(limit int32) ApiGetAmmUserTransactionsV2Request {
	r.limit = &limit
	return r
}

func (r ApiGetAmmUserTransactionsV2Request) Offset(offset int64) ApiGetAmmUserTransactionsV2Request {
	r.offset = &offset
	return r
}

func (r ApiGetAmmUserTransactionsV2Request) TxTypes(txTypes string) ApiGetAmmUserTransactionsV2Request {
	r.txTypes = &txTypes
	return r
}

func (r ApiGetAmmUserTransactionsV2Request) TxStatus(txStatus string) ApiGetAmmUserTransactionsV2Request {
	r.txStatus = &txStatus
	return r
}

func (r ApiGetAmmUserTransactionsV2Request) AmmPoolAddress(ammPoolAddress string) ApiGetAmmUserTransactionsV2Request {
	r.ammPoolAddress = &ammPoolAddress
	return r
}

func (r ApiGetAmmUserTransactionsV2Request) Execute() (*GetAmmTransactionResponseV2, *http.Response, error) {
	return r.ApiService.GetAmmUserTransactionsV2Execute(r)
}

/*
GetAmmUserTransactionsV2 User's AMM join/exit transactions

Return the user's AMM join/exit transactions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAmmUserTransactionsV2Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetAmmUserTransactionsV2(ctx context.Context) ApiGetAmmUserTransactionsV2Request {
	return ApiGetAmmUserTransactionsV2Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GetAmmTransactionResponseV2
func (a *LoopringDEXRestfulAPIApiService) GetAmmUserTransactionsV2Execute(r ApiGetAmmUserTransactionsV2Request) (*GetAmmTransactionResponseV2, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetAmmTransactionResponseV2
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetAmmUserTransactionsV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/amm/user/transactions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.accountId != nil {
		localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	}
	if r.start != nil {
		localVarQueryParams.Add("start", parameterToString(*r.start, ""))
	}
	if r.end != nil {
		localVarQueryParams.Add("end", parameterToString(*r.end, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.txTypes != nil {
		localVarQueryParams.Add("txTypes", parameterToString(*r.txTypes, ""))
	}
	if r.txStatus != nil {
		localVarQueryParams.Add("txStatus", parameterToString(*r.txStatus, ""))
	}
	if r.ammPoolAddress != nil {
		localVarQueryParams.Add("ammPoolAddress", parameterToString(*r.ammPoolAddress, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAmmUserTransactionsV3Request struct {
	ctx            context.Context
	ApiService     *LoopringDEXRestfulAPIApiService
	accountId      *int64
	start          *int64
	end            *int64
	limit          *int32
	offset         *int64
	txTypes        *string
	txStatus       *string
	ammPoolAddress *string
	hashes         *string
}

// Looprings account identifier.
func (r ApiGetAmmUserTransactionsV3Request) AccountId(accountId int64) ApiGetAmmUserTransactionsV3Request {
	r.accountId = &accountId
	return r
}

// Date from which to start fetching AMM transactions.
func (r ApiGetAmmUserTransactionsV3Request) Start(start int64) ApiGetAmmUserTransactionsV3Request {
	r.start = &start
	return r
}

// End Date of the query
func (r ApiGetAmmUserTransactionsV3Request) End(end int64) ApiGetAmmUserTransactionsV3Request {
	r.end = &end
	return r
}

// Used to limit the number of returned records. Useful in implementing pagination.
func (r ApiGetAmmUserTransactionsV3Request) Limit(limit int32) ApiGetAmmUserTransactionsV3Request {
	r.limit = &limit
	return r
}

// Used to apply an offset when looking for valid records. Useful in implementing
func (r ApiGetAmmUserTransactionsV3Request) Offset(offset int64) ApiGetAmmUserTransactionsV3Request {
	r.offset = &offset
	return r
}

// Transaction type: join or exit
func (r ApiGetAmmUserTransactionsV3Request) TxTypes(txTypes string) ApiGetAmmUserTransactionsV3Request {
	r.txTypes = &txTypes
	return r
}

// The AMM transaction status.
func (r ApiGetAmmUserTransactionsV3Request) TxStatus(txStatus string) ApiGetAmmUserTransactionsV3Request {
	r.txStatus = &txStatus
	return r
}

// The address of the pool on which the swap was submitted.
func (r ApiGetAmmUserTransactionsV3Request) AmmPoolAddress(ammPoolAddress string) ApiGetAmmUserTransactionsV3Request {
	r.ammPoolAddress = &ammPoolAddress
	return r
}

// request.getAmmTransactions.hashes
func (r ApiGetAmmUserTransactionsV3Request) Hashes(hashes string) ApiGetAmmUserTransactionsV3Request {
	r.hashes = &hashes
	return r
}

func (r ApiGetAmmUserTransactionsV3Request) Execute() (*AmmTransactionDataListV3, *http.Response, error) {
	return r.ApiService.GetAmmUserTransactionsV3Execute(r)
}

/*
GetAmmUserTransactionsV3 User's AMM join/exit transactions

Return the user's AMM join/exit transactions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAmmUserTransactionsV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetAmmUserTransactionsV3(ctx context.Context) ApiGetAmmUserTransactionsV3Request {
	return ApiGetAmmUserTransactionsV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return AmmTransactionDataListV3
func (a *LoopringDEXRestfulAPIApiService) GetAmmUserTransactionsV3Execute(r ApiGetAmmUserTransactionsV3Request) (*AmmTransactionDataListV3, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AmmTransactionDataListV3
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetAmmUserTransactionsV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/amm/user/transactions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.accountId != nil {
		localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	}
	if r.start != nil {
		localVarQueryParams.Add("start", parameterToString(*r.start, ""))
	}
	if r.end != nil {
		localVarQueryParams.Add("end", parameterToString(*r.end, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.txTypes != nil {
		localVarQueryParams.Add("txTypes", parameterToString(*r.txTypes, ""))
	}
	if r.txStatus != nil {
		localVarQueryParams.Add("txStatus", parameterToString(*r.txStatus, ""))
	}
	if r.ammPoolAddress != nil {
		localVarQueryParams.Add("ammPoolAddress", parameterToString(*r.ammPoolAddress, ""))
	}
	if r.hashes != nil {
		localVarQueryParams.Add("hashes", parameterToString(*r.hashes, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetApiKeyV2Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	accountId  *int64
}

// AccountID
func (r ApiGetApiKeyV2Request) AccountId(accountId int64) ApiGetApiKeyV2Request {
	r.accountId = &accountId
	return r
}

func (r ApiGetApiKeyV2Request) Execute() (*GetApiKeyResponseV2, *http.Response, error) {
	return r.ApiService.GetApiKeyV2Execute(r)
}

/*
GetApiKeyV2 Get user ApiKey

Get the ApiKey associated with the user's account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetApiKeyV2Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetApiKeyV2(ctx context.Context) ApiGetApiKeyV2Request {
	return ApiGetApiKeyV2Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GetApiKeyResponseV2
func (a *LoopringDEXRestfulAPIApiService) GetApiKeyV2Execute(r ApiGetApiKeyV2Request) (*GetApiKeyResponseV2, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetApiKeyResponseV2
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetApiKeyV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/apiKey"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}

	localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetApiKeyV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	accountId  *int64
}

// AccountID
func (r ApiGetApiKeyV3Request) AccountId(accountId int64) ApiGetApiKeyV3Request {
	r.accountId = &accountId
	return r
}

func (r ApiGetApiKeyV3Request) Execute() (*GetApiKeyResponseV3, *http.Response, error) {
	return r.ApiService.GetApiKeyV3Execute(r)
}

/*
GetApiKeyV3 Get user ApiKey

Get the ApiKey associated with the user's account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetApiKeyV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetApiKeyV3(ctx context.Context) ApiGetApiKeyV3Request {
	return ApiGetApiKeyV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GetApiKeyResponseV3
func (a *LoopringDEXRestfulAPIApiService) GetApiKeyV3Execute(r ApiGetApiKeyV3Request) (*GetApiKeyResponseV3, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetApiKeyResponseV3
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetApiKeyV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/apiKey"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}

	localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAvailableBrokerV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
}

func (r ApiGetAvailableBrokerV3Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetAvailableBrokerV3Execute(r)
}

/*
GetAvailableBrokerV3 Method for GetAvailableBrokerV3

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAvailableBrokerV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetAvailableBrokerV3(ctx context.Context) ApiGetAvailableBrokerV3Request {
	return ApiGetAvailableBrokerV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *LoopringDEXRestfulAPIApiService) GetAvailableBrokerV3Execute(r ApiGetAvailableBrokerV3Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetAvailableBrokerV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/getAvailableBroker"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAvailableBrokerV3HebaoRequest struct {
	ctx          context.Context
	ApiService   *LoopringDEXRestfulAPIApiService
	organization *string
}

func (r ApiGetAvailableBrokerV3HebaoRequest) Organization(organization string) ApiGetAvailableBrokerV3HebaoRequest {
	r.organization = &organization
	return r
}

func (r ApiGetAvailableBrokerV3HebaoRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetAvailableBrokerV3HebaoExecute(r)
}

/*
GetAvailableBrokerV3Hebao Method for GetAvailableBrokerV3Hebao

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAvailableBrokerV3HebaoRequest
*/
func (a *LoopringDEXRestfulAPIApiService) GetAvailableBrokerV3Hebao(ctx context.Context) ApiGetAvailableBrokerV3HebaoRequest {
	return ApiGetAvailableBrokerV3HebaoRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *LoopringDEXRestfulAPIApiService) GetAvailableBrokerV3HebaoExecute(r ApiGetAvailableBrokerV3HebaoRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetAvailableBrokerV3Hebao")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/hebao/getAvailableBroker"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.organization != nil {
		localVarQueryParams.Add("organization", parameterToString(*r.organization, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBlockV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	id         *string
}

// The block id, could be finalized, confirmed, or block_idx_num
func (r ApiGetBlockV3Request) Id(id string) ApiGetBlockV3Request {
	r.id = &id
	return r
}

func (r ApiGetBlockV3Request) Execute() (*BlockResp, *http.Response, error) {
	return r.ApiService.GetBlockV3Execute(r)
}

/*
GetBlockV3 Get L2 block info

Get L2 block info by block id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetBlockV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetBlockV3(ctx context.Context) ApiGetBlockV3Request {
	return ApiGetBlockV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return BlockResp
func (a *LoopringDEXRestfulAPIApiService) GetBlockV3Execute(r ApiGetBlockV3Request) (*BlockResp, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BlockResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetBlockV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/block/getBlock"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBusinessFee2V2Request struct {
	ctx         context.Context
	ApiService  *LoopringDEXRestfulAPIApiService
	accountId   *int32
	requestType *int32
	tokenSymbol *string
	amount      *string
}

// Account ID
func (r ApiGetBusinessFee2V2Request) AccountId(accountId int32) ApiGetBusinessFee2V2Request {
	r.accountId = &accountId
	return r
}

// Off-chain request type
func (r ApiGetBusinessFee2V2Request) RequestType(requestType int32) ApiGetBusinessFee2V2Request {
	r.requestType = &requestType
	return r
}

// The token to withdraw
func (r ApiGetBusinessFee2V2Request) TokenSymbol(tokenSymbol string) ApiGetBusinessFee2V2Request {
	r.tokenSymbol = &tokenSymbol
	return r
}

// The amount to withdraw
func (r ApiGetBusinessFee2V2Request) Amount(amount string) ApiGetBusinessFee2V2Request {
	r.amount = &amount
	return r
}

func (r ApiGetBusinessFee2V2Request) Execute() (*GetOffchainFee2Response, *http.Response, error) {
	return r.ApiService.GetBusinessFee2V2Execute(r)
}

/*
GetBusinessFee2V2 Query current fee amount

Returns the fee amount

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetBusinessFee2V2Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetBusinessFee2V2(ctx context.Context) ApiGetBusinessFee2V2Request {
	return ApiGetBusinessFee2V2Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GetOffchainFee2Response
func (a *LoopringDEXRestfulAPIApiService) GetBusinessFee2V2Execute(r ApiGetBusinessFee2V2Request) (*GetOffchainFee2Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetOffchainFee2Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetBusinessFee2V2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/user/offchainFee"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.requestType == nil {
		return localVarReturnValue, nil, reportError("requestType is required and must be specified")
	}

	localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	localVarQueryParams.Add("requestType", parameterToString(*r.requestType, ""))
	if r.tokenSymbol != nil {
		localVarQueryParams.Add("tokenSymbol", parameterToString(*r.tokenSymbol, ""))
	}
	if r.amount != nil {
		localVarQueryParams.Add("amount", parameterToString(*r.amount, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBusinessFee2V3Request struct {
	ctx         context.Context
	ApiService  *LoopringDEXRestfulAPIApiService
	accountId   *int32
	requestType *int32
	tokenSymbol *string
	amount      *string
	market      *string
}

// Account ID
func (r ApiGetBusinessFee2V3Request) AccountId(accountId int32) ApiGetBusinessFee2V3Request {
	r.accountId = &accountId
	return r
}

// Off-chain request type
func (r ApiGetBusinessFee2V3Request) RequestType(requestType int32) ApiGetBusinessFee2V3Request {
	r.requestType = &requestType
	return r
}

// The token to withdraw
func (r ApiGetBusinessFee2V3Request) TokenSymbol(tokenSymbol string) ApiGetBusinessFee2V3Request {
	r.tokenSymbol = &tokenSymbol
	return r
}

// The amount to withdraw
func (r ApiGetBusinessFee2V3Request) Amount(amount string) ApiGetBusinessFee2V3Request {
	r.amount = &amount
	return r
}

// The market
func (r ApiGetBusinessFee2V3Request) Market(market string) ApiGetBusinessFee2V3Request {
	r.market = &market
	return r
}

func (r ApiGetBusinessFee2V3Request) Execute() (*OffFeeInfo2, *http.Response, error) {
	return r.ApiService.GetBusinessFee2V3Execute(r)
}

/*
GetBusinessFee2V3 Query current fee amount

Returns the fee amount

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetBusinessFee2V3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetBusinessFee2V3(ctx context.Context) ApiGetBusinessFee2V3Request {
	return ApiGetBusinessFee2V3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return OffFeeInfo2
func (a *LoopringDEXRestfulAPIApiService) GetBusinessFee2V3Execute(r ApiGetBusinessFee2V3Request) (*OffFeeInfo2, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *OffFeeInfo2
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetBusinessFee2V3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/user/offchainFee"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.requestType == nil {
		return localVarReturnValue, nil, reportError("requestType is required and must be specified")
	}

	localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	localVarQueryParams.Add("requestType", parameterToString(*r.requestType, ""))
	if r.tokenSymbol != nil {
		localVarQueryParams.Add("tokenSymbol", parameterToString(*r.tokenSymbol, ""))
	}
	if r.amount != nil {
		localVarQueryParams.Add("amount", parameterToString(*r.amount, ""))
	}
	if r.market != nil {
		localVarQueryParams.Add("market", parameterToString(*r.market, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCandlestickV2Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	market     *string
	interval   *string
	start      *int64
	end        *int64
	limit      *int32
}

// Trading pair ID, multi-market is not supported
func (r ApiGetCandlestickV2Request) Market(market string) ApiGetCandlestickV2Request {
	r.market = &market
	return r
}

// Candlestick interval, Supported values are: 1min, 5min, 15min, 30min, 1hr, 2hr, 4hr, 12hr, 1d, 1w
func (r ApiGetCandlestickV2Request) Interval(interval string) ApiGetCandlestickV2Request {
	r.interval = &interval
	return r
}

// Start time
func (r ApiGetCandlestickV2Request) Start(start int64) ApiGetCandlestickV2Request {
	r.start = &start
	return r
}

// End time
func (r ApiGetCandlestickV2Request) End(end int64) ApiGetCandlestickV2Request {
	r.end = &end
	return r
}

// Number of data points. If more data points are available, the API will only return the first &#39;limit&#39; data points.
func (r ApiGetCandlestickV2Request) Limit(limit int32) ApiGetCandlestickV2Request {
	r.limit = &limit
	return r
}

func (r ApiGetCandlestickV2Request) Execute() (*GetCandlestickResponseV2, *http.Response, error) {
	return r.ApiService.GetCandlestickV2Execute(r)
}

/*
GetCandlestickV2 Get market candlestick

Return the candlestick data of a given trading pair.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCandlestickV2Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetCandlestickV2(ctx context.Context) ApiGetCandlestickV2Request {
	return ApiGetCandlestickV2Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GetCandlestickResponseV2
func (a *LoopringDEXRestfulAPIApiService) GetCandlestickV2Execute(r ApiGetCandlestickV2Request) (*GetCandlestickResponseV2, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetCandlestickResponseV2
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetCandlestickV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/candlestick"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.market == nil {
		return localVarReturnValue, nil, reportError("market is required and must be specified")
	}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	localVarQueryParams.Add("market", parameterToString(*r.market, ""))
	localVarQueryParams.Add("interval", parameterToString(*r.interval, ""))
	if r.start != nil {
		localVarQueryParams.Add("start", parameterToString(*r.start, ""))
	}
	if r.end != nil {
		localVarQueryParams.Add("end", parameterToString(*r.end, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCandlestickV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	market     *string
	interval   *string
	start      *int64
	end        *int64
	limit      *int32
}

// Trading pair ID, multi-market is not supported
func (r ApiGetCandlestickV3Request) Market(market string) ApiGetCandlestickV3Request {
	r.market = &market
	return r
}

// Candlestick interval, Supported values are: 1min, 5min, 15min, 30min, 1hr, 2hr, 4hr, 12hr, 1d, 1w
func (r ApiGetCandlestickV3Request) Interval(interval string) ApiGetCandlestickV3Request {
	r.interval = &interval
	return r
}

// Start time
func (r ApiGetCandlestickV3Request) Start(start int64) ApiGetCandlestickV3Request {
	r.start = &start
	return r
}

// End time
func (r ApiGetCandlestickV3Request) End(end int64) ApiGetCandlestickV3Request {
	r.end = &end
	return r
}

// Number of data points. If more data points are available, the API will only return the first &#39;limit&#39; data points.
func (r ApiGetCandlestickV3Request) Limit(limit int32) ApiGetCandlestickV3Request {
	r.limit = &limit
	return r
}

func (r ApiGetCandlestickV3Request) Execute() (*GetCandlestickResponseV3, *http.Response, error) {
	return r.ApiService.GetCandlestickV3Execute(r)
}

/*
GetCandlestickV3 Get market candlestick

Return the candlestick data of a given trading pair.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCandlestickV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetCandlestickV3(ctx context.Context) ApiGetCandlestickV3Request {
	return ApiGetCandlestickV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GetCandlestickResponseV3
func (a *LoopringDEXRestfulAPIApiService) GetCandlestickV3Execute(r ApiGetCandlestickV3Request) (*GetCandlestickResponseV3, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetCandlestickResponseV3
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetCandlestickV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/candlestick"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.market == nil {
		return localVarReturnValue, nil, reportError("market is required and must be specified")
	}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	localVarQueryParams.Add("market", parameterToString(*r.market, ""))
	localVarQueryParams.Add("interval", parameterToString(*r.interval, ""))
	if r.start != nil {
		localVarQueryParams.Add("start", parameterToString(*r.start, ""))
	}
	if r.end != nil {
		localVarQueryParams.Add("end", parameterToString(*r.end, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetClaimHistoryV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	fromId     *int64
	limit      *int32
}

func (r ApiGetClaimHistoryV3Request) FromId(fromId int64) ApiGetClaimHistoryV3Request {
	r.fromId = &fromId
	return r
}

func (r ApiGetClaimHistoryV3Request) Limit(limit int32) ApiGetClaimHistoryV3Request {
	r.limit = &limit
	return r
}

func (r ApiGetClaimHistoryV3Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetClaimHistoryV3Execute(r)
}

/*
GetClaimHistoryV3 Method for GetClaimHistoryV3

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetClaimHistoryV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetClaimHistoryV3(ctx context.Context) ApiGetClaimHistoryV3Request {
	return ApiGetClaimHistoryV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *LoopringDEXRestfulAPIApiService) GetClaimHistoryV3Execute(r ApiGetClaimHistoryV3Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetClaimHistoryV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/luckyToken/user/claimHistory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fromId != nil {
		localVarQueryParams.Add("fromId", parameterToString(*r.fromId, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetClaimLuckyTokenRecordsV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	hash       *string
	fromId     *int64
	limit      *int32
	showHelper *bool
}

func (r ApiGetClaimLuckyTokenRecordsV3Request) Hash(hash string) ApiGetClaimLuckyTokenRecordsV3Request {
	r.hash = &hash
	return r
}

func (r ApiGetClaimLuckyTokenRecordsV3Request) FromId(fromId int64) ApiGetClaimLuckyTokenRecordsV3Request {
	r.fromId = &fromId
	return r
}

func (r ApiGetClaimLuckyTokenRecordsV3Request) Limit(limit int32) ApiGetClaimLuckyTokenRecordsV3Request {
	r.limit = &limit
	return r
}

func (r ApiGetClaimLuckyTokenRecordsV3Request) ShowHelper(showHelper bool) ApiGetClaimLuckyTokenRecordsV3Request {
	r.showHelper = &showHelper
	return r
}

func (r ApiGetClaimLuckyTokenRecordsV3Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetClaimLuckyTokenRecordsV3Execute(r)
}

/*
GetClaimLuckyTokenRecordsV3 Method for GetClaimLuckyTokenRecordsV3

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetClaimLuckyTokenRecordsV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetClaimLuckyTokenRecordsV3(ctx context.Context) ApiGetClaimLuckyTokenRecordsV3Request {
	return ApiGetClaimLuckyTokenRecordsV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *LoopringDEXRestfulAPIApiService) GetClaimLuckyTokenRecordsV3Execute(r ApiGetClaimLuckyTokenRecordsV3Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetClaimLuckyTokenRecordsV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/luckyToken/user/luckyTokenDetail"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.hash != nil {
		localVarQueryParams.Add("hash", parameterToString(*r.hash, ""))
	}
	if r.fromId != nil {
		localVarQueryParams.Add("fromId", parameterToString(*r.fromId, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.showHelper != nil {
		localVarQueryParams.Add("showHelper", parameterToString(*r.showHelper, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetClaimLuckyTokenV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	hashes     *string
	fromId     *int64
	limit      *int32
}

func (r ApiGetClaimLuckyTokenV3Request) Hashes(hashes string) ApiGetClaimLuckyTokenV3Request {
	r.hashes = &hashes
	return r
}

func (r ApiGetClaimLuckyTokenV3Request) FromId(fromId int64) ApiGetClaimLuckyTokenV3Request {
	r.fromId = &fromId
	return r
}

func (r ApiGetClaimLuckyTokenV3Request) Limit(limit int32) ApiGetClaimLuckyTokenV3Request {
	r.limit = &limit
	return r
}

func (r ApiGetClaimLuckyTokenV3Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetClaimLuckyTokenV3Execute(r)
}

/*
GetClaimLuckyTokenV3 Method for GetClaimLuckyTokenV3

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetClaimLuckyTokenV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetClaimLuckyTokenV3(ctx context.Context) ApiGetClaimLuckyTokenV3Request {
	return ApiGetClaimLuckyTokenV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *LoopringDEXRestfulAPIApiService) GetClaimLuckyTokenV3Execute(r ApiGetClaimLuckyTokenV3Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetClaimLuckyTokenV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/luckyToken/user/claimedLuckyTokens"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.hashes != nil {
		localVarQueryParams.Add("hashes", parameterToString(*r.hashes, ""))
	}
	if r.fromId != nil {
		localVarQueryParams.Add("fromId", parameterToString(*r.fromId, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCommissionRewardRankV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	tokenId    *int32
	top        *int32
	rewardType *int32
}

func (r ApiGetCommissionRewardRankV3Request) TokenId(tokenId int32) ApiGetCommissionRewardRankV3Request {
	r.tokenId = &tokenId
	return r
}

func (r ApiGetCommissionRewardRankV3Request) Top(top int32) ApiGetCommissionRewardRankV3Request {
	r.top = &top
	return r
}

func (r ApiGetCommissionRewardRankV3Request) RewardType(rewardType int32) ApiGetCommissionRewardRankV3Request {
	r.rewardType = &rewardType
	return r
}

func (r ApiGetCommissionRewardRankV3Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetCommissionRewardRankV3Execute(r)
}

/*
GetCommissionRewardRankV3 Method for GetCommissionRewardRankV3

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCommissionRewardRankV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetCommissionRewardRankV3(ctx context.Context) ApiGetCommissionRewardRankV3Request {
	return ApiGetCommissionRewardRankV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *LoopringDEXRestfulAPIApiService) GetCommissionRewardRankV3Execute(r ApiGetCommissionRewardRankV3Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetCommissionRewardRankV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/sidecar/commissionRewardRank"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.tokenId != nil {
		localVarQueryParams.Add("tokenId", parameterToString(*r.tokenId, ""))
	}
	if r.top != nil {
		localVarQueryParams.Add("top", parameterToString(*r.top, ""))
	}
	if r.rewardType != nil {
		localVarQueryParams.Add("rewardType", parameterToString(*r.rewardType, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCommissionRewardV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	accountId  *int64
	tokenId    *int32
	start      *int64
	size       *int32
	rewardType *int32
	taker      *int32
}

func (r ApiGetCommissionRewardV3Request) AccountId(accountId int64) ApiGetCommissionRewardV3Request {
	r.accountId = &accountId
	return r
}

func (r ApiGetCommissionRewardV3Request) TokenId(tokenId int32) ApiGetCommissionRewardV3Request {
	r.tokenId = &tokenId
	return r
}

func (r ApiGetCommissionRewardV3Request) Start(start int64) ApiGetCommissionRewardV3Request {
	r.start = &start
	return r
}

func (r ApiGetCommissionRewardV3Request) Size(size int32) ApiGetCommissionRewardV3Request {
	r.size = &size
	return r
}

func (r ApiGetCommissionRewardV3Request) RewardType(rewardType int32) ApiGetCommissionRewardV3Request {
	r.rewardType = &rewardType
	return r
}

func (r ApiGetCommissionRewardV3Request) Taker(taker int32) ApiGetCommissionRewardV3Request {
	r.taker = &taker
	return r
}

func (r ApiGetCommissionRewardV3Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetCommissionRewardV3Execute(r)
}

/*
GetCommissionRewardV3 Method for GetCommissionRewardV3

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCommissionRewardV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetCommissionRewardV3(ctx context.Context) ApiGetCommissionRewardV3Request {
	return ApiGetCommissionRewardV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *LoopringDEXRestfulAPIApiService) GetCommissionRewardV3Execute(r ApiGetCommissionRewardV3Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetCommissionRewardV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/sidecar/commissionReward"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.accountId != nil {
		localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	}
	if r.tokenId != nil {
		localVarQueryParams.Add("tokenId", parameterToString(*r.tokenId, ""))
	}
	if r.start != nil {
		localVarQueryParams.Add("start", parameterToString(*r.start, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.rewardType != nil {
		localVarQueryParams.Add("rewardType", parameterToString(*r.rewardType, ""))
	}
	if r.taker != nil {
		localVarQueryParams.Add("taker", parameterToString(*r.taker, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCommissionTotalRewardV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	accountId  *int64
}

func (r ApiGetCommissionTotalRewardV3Request) AccountId(accountId int64) ApiGetCommissionTotalRewardV3Request {
	r.accountId = &accountId
	return r
}

func (r ApiGetCommissionTotalRewardV3Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetCommissionTotalRewardV3Execute(r)
}

/*
GetCommissionTotalRewardV3 Method for GetCommissionTotalRewardV3

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCommissionTotalRewardV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetCommissionTotalRewardV3(ctx context.Context) ApiGetCommissionTotalRewardV3Request {
	return ApiGetCommissionTotalRewardV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *LoopringDEXRestfulAPIApiService) GetCommissionTotalRewardV3Execute(r ApiGetCommissionTotalRewardV3Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetCommissionTotalRewardV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/sidecar/commissionRewardTotal"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.accountId != nil {
		localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCounterFactualInfoV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	accountId  *string
}

func (r ApiGetCounterFactualInfoV3Request) AccountId(accountId string) ApiGetCounterFactualInfoV3Request {
	r.accountId = &accountId
	return r
}

func (r ApiGetCounterFactualInfoV3Request) Execute() (*AccountCounterFactualInfo, *http.Response, error) {
	return r.ApiService.GetCounterFactualInfoV3Execute(r)
}

/*
GetCounterFactualInfoV3 api.getCounterFactualInfo.value

api.getCounterFactualInfo.notes

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCounterFactualInfoV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetCounterFactualInfoV3(ctx context.Context) ApiGetCounterFactualInfoV3Request {
	return ApiGetCounterFactualInfoV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return AccountCounterFactualInfo
func (a *LoopringDEXRestfulAPIApiService) GetCounterFactualInfoV3Execute(r ApiGetCounterFactualInfoV3Request) (*AccountCounterFactualInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AccountCounterFactualInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetCounterFactualInfoV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/counterFactualInfo"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.accountId != nil {
		localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCurrencyRatesV2Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	currencies *string
}

// Currency symbol to be queried
func (r ApiGetCurrencyRatesV2Request) Currencies(currencies string) ApiGetCurrencyRatesV2Request {
	r.currencies = &currencies
	return r
}

func (r ApiGetCurrencyRatesV2Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetCurrencyRatesV2Execute(r)
}

/*
GetCurrencyRatesV2 Method for GetCurrencyRatesV2

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCurrencyRatesV2Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetCurrencyRatesV2(ctx context.Context) ApiGetCurrencyRatesV2Request {
	return ApiGetCurrencyRatesV2Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *LoopringDEXRestfulAPIApiService) GetCurrencyRatesV2Execute(r ApiGetCurrencyRatesV2Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetCurrencyRatesV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/currencyRates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.currencies == nil {
		return localVarReturnValue, nil, reportError("currencies is required and must be specified")
	}

	localVarQueryParams.Add("currencies", parameterToString(*r.currencies, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDaoSquareAccountsV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	startTime  *int64
	endTime    *int64
}

func (r ApiGetDaoSquareAccountsV3Request) StartTime(startTime int64) ApiGetDaoSquareAccountsV3Request {
	r.startTime = &startTime
	return r
}

func (r ApiGetDaoSquareAccountsV3Request) EndTime(endTime int64) ApiGetDaoSquareAccountsV3Request {
	r.endTime = &endTime
	return r
}

func (r ApiGetDaoSquareAccountsV3Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetDaoSquareAccountsV3Execute(r)
}

/*
GetDaoSquareAccountsV3 Method for GetDaoSquareAccountsV3

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetDaoSquareAccountsV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetDaoSquareAccountsV3(ctx context.Context) ApiGetDaoSquareAccountsV3Request {
	return ApiGetDaoSquareAccountsV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *LoopringDEXRestfulAPIApiService) GetDaoSquareAccountsV3Execute(r ApiGetDaoSquareAccountsV3Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetDaoSquareAccountsV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/user/daoSquareAccounts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startTime != nil {
		localVarQueryParams.Add("startTime", parameterToString(*r.startTime, ""))
	}
	if r.endTime != nil {
		localVarQueryParams.Add("endTime", parameterToString(*r.endTime, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDepthV2Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	market     *string
	level      *int32
	limit      *int32
}

// The ID of a trading pair.
func (r ApiGetDepthV2Request) Market(market string) ApiGetDepthV2Request {
	r.market = &market
	return r
}

// Order book aggregation level, larger value means further price aggregation.
func (r ApiGetDepthV2Request) Level(level int32) ApiGetDepthV2Request {
	r.level = &level
	return r
}

// Maximum numbers of bids/asks.
func (r ApiGetDepthV2Request) Limit(limit int32) ApiGetDepthV2Request {
	r.limit = &limit
	return r
}

func (r ApiGetDepthV2Request) Execute() (*GetDepthResponseV2, *http.Response, error) {
	return r.ApiService.GetDepthV2Execute(r)
}

/*
GetDepthV2 Get market orderbook

Returns the order book of a given trading pair.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetDepthV2Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetDepthV2(ctx context.Context) ApiGetDepthV2Request {
	return ApiGetDepthV2Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GetDepthResponseV2
func (a *LoopringDEXRestfulAPIApiService) GetDepthV2Execute(r ApiGetDepthV2Request) (*GetDepthResponseV2, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetDepthResponseV2
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetDepthV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/depth"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.market == nil {
		return localVarReturnValue, nil, reportError("market is required and must be specified")
	}
	if r.level == nil {
		return localVarReturnValue, nil, reportError("level is required and must be specified")
	}

	localVarQueryParams.Add("market", parameterToString(*r.market, ""))
	localVarQueryParams.Add("level", parameterToString(*r.level, ""))
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDepthV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	market     *string
	level      *int32
	limit      *int32
}

// The ID of a trading pair.
func (r ApiGetDepthV3Request) Market(market string) ApiGetDepthV3Request {
	r.market = &market
	return r
}

// Order book aggregation level, larger value means further price aggregation.
func (r ApiGetDepthV3Request) Level(level int32) ApiGetDepthV3Request {
	r.level = &level
	return r
}

// Maximum numbers of bids/asks.
func (r ApiGetDepthV3Request) Limit(limit int32) ApiGetDepthV3Request {
	r.limit = &limit
	return r
}

func (r ApiGetDepthV3Request) Execute() (*DepthV3, *http.Response, error) {
	return r.ApiService.GetDepthV3Execute(r)
}

/*
GetDepthV3 Get market orderbook

Returns the order book of a given trading pair.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetDepthV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetDepthV3(ctx context.Context) ApiGetDepthV3Request {
	return ApiGetDepthV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return DepthV3
func (a *LoopringDEXRestfulAPIApiService) GetDepthV3Execute(r ApiGetDepthV3Request) (*DepthV3, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DepthV3
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetDepthV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/depth"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.market == nil {
		return localVarReturnValue, nil, reportError("market is required and must be specified")
	}
	if r.level == nil {
		return localVarReturnValue, nil, reportError("level is required and must be specified")
	}

	localVarQueryParams.Add("market", parameterToString(*r.market, ""))
	localVarQueryParams.Add("level", parameterToString(*r.level, ""))
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEthBalanceV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	owner      *string
}

// Ethereum address
func (r ApiGetEthBalanceV3Request) Owner(owner string) ApiGetEthBalanceV3Request {
	r.owner = &owner
	return r
}

func (r ApiGetEthBalanceV3Request) Execute() (*GetEthBalancesV2Response, *http.Response, error) {
	return r.ApiService.GetEthBalanceV3Execute(r)
}

/*
GetEthBalanceV3 Get user's Ether balance on Ethereum mainnet

Returns user's Ether balance on Ethereum mainnet (not the Ether balance on Loopring.io)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetEthBalanceV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetEthBalanceV3(ctx context.Context) ApiGetEthBalanceV3Request {
	return ApiGetEthBalanceV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GetEthBalancesV2Response
func (a *LoopringDEXRestfulAPIApiService) GetEthBalanceV3Execute(r ApiGetEthBalanceV3Request) (*GetEthBalancesV2Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetEthBalancesV2Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetEthBalanceV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/eth/balances"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.owner == nil {
		return localVarReturnValue, nil, reportError("owner is required and must be specified")
	}

	localVarQueryParams.Add("owner", parameterToString(*r.owner, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEthNonceV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	owner      *string
}

// Ethereum address
func (r ApiGetEthNonceV3Request) Owner(owner string) ApiGetEthNonceV3Request {
	r.owner = &owner
	return r
}

func (r ApiGetEthNonceV3Request) Execute() (*GetEthNonceV2Response, *http.Response, error) {
	return r.ApiService.GetEthNonceV3Execute(r)
}

/*
GetEthNonceV3 Get user's next Ethereum nonce

Returns the next nonce of the Ethereum address associated with the user's account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetEthNonceV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetEthNonceV3(ctx context.Context) ApiGetEthNonceV3Request {
	return ApiGetEthNonceV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GetEthNonceV2Response
func (a *LoopringDEXRestfulAPIApiService) GetEthNonceV3Execute(r ApiGetEthNonceV3Request) (*GetEthNonceV2Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetEthNonceV2Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetEthNonceV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/eth/nonce"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.owner == nil {
		return localVarReturnValue, nil, reportError("owner is required and must be specified")
	}

	localVarQueryParams.Add("owner", parameterToString(*r.owner, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetExchangeFeeInfoV2Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
}

func (r ApiGetExchangeFeeInfoV2Request) Execute() (*GetExchangeFeeInfoResponse, *http.Response, error) {
	return r.ApiService.GetExchangeFeeInfoV2Execute(r)
}

/*
GetExchangeFeeInfoV2 Get exchange configurations

Return various configurations of Loopring.io

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetExchangeFeeInfoV2Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetExchangeFeeInfoV2(ctx context.Context) ApiGetExchangeFeeInfoV2Request {
	return ApiGetExchangeFeeInfoV2Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GetExchangeFeeInfoResponse
func (a *LoopringDEXRestfulAPIApiService) GetExchangeFeeInfoV2Execute(r ApiGetExchangeFeeInfoV2Request) (*GetExchangeFeeInfoResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetExchangeFeeInfoResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetExchangeFeeInfoV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/exchange/feeInfo"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetExchangeFeeInfoV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
}

func (r ApiGetExchangeFeeInfoV3Request) Execute() (*GetExchangeFeeInfoResponseData, *http.Response, error) {
	return r.ApiService.GetExchangeFeeInfoV3Execute(r)
}

/*
GetExchangeFeeInfoV3 Get exchange configurations

Return various configurations of Loopring.io

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetExchangeFeeInfoV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetExchangeFeeInfoV3(ctx context.Context) ApiGetExchangeFeeInfoV3Request {
	return ApiGetExchangeFeeInfoV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GetExchangeFeeInfoResponseData
func (a *LoopringDEXRestfulAPIApiService) GetExchangeFeeInfoV3Execute(r ApiGetExchangeFeeInfoV3Request) (*GetExchangeFeeInfoResponseData, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetExchangeFeeInfoResponseData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetExchangeFeeInfoV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/exchange/feeInfo"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetExchangeInfoV2Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
}

func (r ApiGetExchangeInfoV2Request) Execute() (*GetExchangeInfoResponse, *http.Response, error) {
	return r.ApiService.GetExchangeInfoV2Execute(r)
}

/*
GetExchangeInfoV2 Get exchange configurations

Return various configurations of Loopring.io

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetExchangeInfoV2Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetExchangeInfoV2(ctx context.Context) ApiGetExchangeInfoV2Request {
	return ApiGetExchangeInfoV2Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GetExchangeInfoResponse
func (a *LoopringDEXRestfulAPIApiService) GetExchangeInfoV2Execute(r ApiGetExchangeInfoV2Request) (*GetExchangeInfoResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetExchangeInfoResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetExchangeInfoV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/exchange/info"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetExchangeInfoV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
}

func (r ApiGetExchangeInfoV3Request) Execute() (*ExchangeInfo, *http.Response, error) {
	return r.ApiService.GetExchangeInfoV3Execute(r)
}

/*
GetExchangeInfoV3 Get exchange configurations

Return various configurations of Loopring.io

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetExchangeInfoV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetExchangeInfoV3(ctx context.Context) ApiGetExchangeInfoV3Request {
	return ApiGetExchangeInfoV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return ExchangeInfo
func (a *LoopringDEXRestfulAPIApiService) GetExchangeInfoV3Execute(r ApiGetExchangeInfoV3Request) (*ExchangeInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ExchangeInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetExchangeInfoV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/exchange/info"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFinanceIncomeV3Request struct {
	ctx          context.Context
	ApiService   *LoopringDEXRestfulAPIApiService
	address      *string
	financeType  *string
	tokenAddress *string
	offset       *int64
	limit        *int32
}

func (r ApiGetFinanceIncomeV3Request) Address(address string) ApiGetFinanceIncomeV3Request {
	r.address = &address
	return r
}

func (r ApiGetFinanceIncomeV3Request) FinanceType(financeType string) ApiGetFinanceIncomeV3Request {
	r.financeType = &financeType
	return r
}

func (r ApiGetFinanceIncomeV3Request) TokenAddress(tokenAddress string) ApiGetFinanceIncomeV3Request {
	r.tokenAddress = &tokenAddress
	return r
}

func (r ApiGetFinanceIncomeV3Request) Offset(offset int64) ApiGetFinanceIncomeV3Request {
	r.offset = &offset
	return r
}

func (r ApiGetFinanceIncomeV3Request) Limit(limit int32) ApiGetFinanceIncomeV3Request {
	r.limit = &limit
	return r
}

func (r ApiGetFinanceIncomeV3Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetFinanceIncomeV3Execute(r)
}

/*
GetFinanceIncomeV3 Method for GetFinanceIncomeV3

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetFinanceIncomeV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetFinanceIncomeV3(ctx context.Context) ApiGetFinanceIncomeV3Request {
	return ApiGetFinanceIncomeV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *LoopringDEXRestfulAPIApiService) GetFinanceIncomeV3Execute(r ApiGetFinanceIncomeV3Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetFinanceIncomeV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/user/financeIncome"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.address != nil {
		localVarQueryParams.Add("address", parameterToString(*r.address, ""))
	}
	if r.financeType != nil {
		localVarQueryParams.Add("financeType", parameterToString(*r.financeType, ""))
	}
	if r.tokenAddress != nil {
		localVarQueryParams.Add("tokenAddress", parameterToString(*r.tokenAddress, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLatestTokenPricesV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	tokens     *string
	currency   *string
}

func (r ApiGetLatestTokenPricesV3Request) Tokens(tokens string) ApiGetLatestTokenPricesV3Request {
	r.tokens = &tokens
	return r
}

func (r ApiGetLatestTokenPricesV3Request) Currency(currency string) ApiGetLatestTokenPricesV3Request {
	r.currency = &currency
	return r
}

func (r ApiGetLatestTokenPricesV3Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetLatestTokenPricesV3Execute(r)
}

/*
GetLatestTokenPricesV3 Method for GetLatestTokenPricesV3

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetLatestTokenPricesV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetLatestTokenPricesV3(ctx context.Context) ApiGetLatestTokenPricesV3Request {
	return ApiGetLatestTokenPricesV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *LoopringDEXRestfulAPIApiService) GetLatestTokenPricesV3Execute(r ApiGetLatestTokenPricesV3Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetLatestTokenPricesV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/datacenter/getLatestTokenPrices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.tokens != nil {
		localVarQueryParams.Add("tokens", parameterToString(*r.tokens, ""))
	}
	if r.currency != nil {
		localVarQueryParams.Add("currency", parameterToString(*r.currency, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLiquidityMiningConfV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	market     *string
	running    *bool
	pageIndex  *int32
	size       *int32
}

func (r ApiGetLiquidityMiningConfV3Request) Market(market string) ApiGetLiquidityMiningConfV3Request {
	r.market = &market
	return r
}

func (r ApiGetLiquidityMiningConfV3Request) Running(running bool) ApiGetLiquidityMiningConfV3Request {
	r.running = &running
	return r
}

func (r ApiGetLiquidityMiningConfV3Request) PageIndex(pageIndex int32) ApiGetLiquidityMiningConfV3Request {
	r.pageIndex = &pageIndex
	return r
}

func (r ApiGetLiquidityMiningConfV3Request) Size(size int32) ApiGetLiquidityMiningConfV3Request {
	r.size = &size
	return r
}

func (r ApiGetLiquidityMiningConfV3Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetLiquidityMiningConfV3Execute(r)
}

/*
GetLiquidityMiningConfV3 Method for GetLiquidityMiningConfV3

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetLiquidityMiningConfV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetLiquidityMiningConfV3(ctx context.Context) ApiGetLiquidityMiningConfV3Request {
	return ApiGetLiquidityMiningConfV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *LoopringDEXRestfulAPIApiService) GetLiquidityMiningConfV3Execute(r ApiGetLiquidityMiningConfV3Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetLiquidityMiningConfV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/sidecar/liquidityMiningConf"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.market != nil {
		localVarQueryParams.Add("market", parameterToString(*r.market, ""))
	}
	if r.running != nil {
		localVarQueryParams.Add("running", parameterToString(*r.running, ""))
	}
	if r.pageIndex != nil {
		localVarQueryParams.Add("pageIndex", parameterToString(*r.pageIndex, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLiquidityMiningRankV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	market     *string
	top        *int32
}

func (r ApiGetLiquidityMiningRankV3Request) Market(market string) ApiGetLiquidityMiningRankV3Request {
	r.market = &market
	return r
}

func (r ApiGetLiquidityMiningRankV3Request) Top(top int32) ApiGetLiquidityMiningRankV3Request {
	r.top = &top
	return r
}

func (r ApiGetLiquidityMiningRankV3Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetLiquidityMiningRankV3Execute(r)
}

/*
GetLiquidityMiningRankV3 Method for GetLiquidityMiningRankV3

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetLiquidityMiningRankV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetLiquidityMiningRankV3(ctx context.Context) ApiGetLiquidityMiningRankV3Request {
	return ApiGetLiquidityMiningRankV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *LoopringDEXRestfulAPIApiService) GetLiquidityMiningRankV3Execute(r ApiGetLiquidityMiningRankV3Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetLiquidityMiningRankV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/sidecar/liquidityMiningRank"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.market != nil {
		localVarQueryParams.Add("market", parameterToString(*r.market, ""))
	}
	if r.top != nil {
		localVarQueryParams.Add("top", parameterToString(*r.top, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLiquidityMiningRewardTotalV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	accountId  *int64
}

func (r ApiGetLiquidityMiningRewardTotalV3Request) AccountId(accountId int64) ApiGetLiquidityMiningRewardTotalV3Request {
	r.accountId = &accountId
	return r
}

func (r ApiGetLiquidityMiningRewardTotalV3Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetLiquidityMiningRewardTotalV3Execute(r)
}

/*
GetLiquidityMiningRewardTotalV3 Method for GetLiquidityMiningRewardTotalV3

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetLiquidityMiningRewardTotalV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetLiquidityMiningRewardTotalV3(ctx context.Context) ApiGetLiquidityMiningRewardTotalV3Request {
	return ApiGetLiquidityMiningRewardTotalV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *LoopringDEXRestfulAPIApiService) GetLiquidityMiningRewardTotalV3Execute(r ApiGetLiquidityMiningRewardTotalV3Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetLiquidityMiningRewardTotalV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/sidecar/liquidityMiningTotal"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.accountId != nil {
		localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLiquidityMiningRewardsV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	accountId  *int64
	market     *string
	start      *int64
	timestamp  *int64
	size       *int32
}

func (r ApiGetLiquidityMiningRewardsV3Request) AccountId(accountId int64) ApiGetLiquidityMiningRewardsV3Request {
	r.accountId = &accountId
	return r
}

func (r ApiGetLiquidityMiningRewardsV3Request) Market(market string) ApiGetLiquidityMiningRewardsV3Request {
	r.market = &market
	return r
}

func (r ApiGetLiquidityMiningRewardsV3Request) Start(start int64) ApiGetLiquidityMiningRewardsV3Request {
	r.start = &start
	return r
}

func (r ApiGetLiquidityMiningRewardsV3Request) Timestamp(timestamp int64) ApiGetLiquidityMiningRewardsV3Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetLiquidityMiningRewardsV3Request) Size(size int32) ApiGetLiquidityMiningRewardsV3Request {
	r.size = &size
	return r
}

func (r ApiGetLiquidityMiningRewardsV3Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetLiquidityMiningRewardsV3Execute(r)
}

/*
GetLiquidityMiningRewardsV3 Method for GetLiquidityMiningRewardsV3

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetLiquidityMiningRewardsV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetLiquidityMiningRewardsV3(ctx context.Context) ApiGetLiquidityMiningRewardsV3Request {
	return ApiGetLiquidityMiningRewardsV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *LoopringDEXRestfulAPIApiService) GetLiquidityMiningRewardsV3Execute(r ApiGetLiquidityMiningRewardsV3Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetLiquidityMiningRewardsV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/sidecar/liquidityMining"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.accountId != nil {
		localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	}
	if r.market != nil {
		localVarQueryParams.Add("market", parameterToString(*r.market, ""))
	}
	if r.start != nil {
		localVarQueryParams.Add("start", parameterToString(*r.start, ""))
	}
	if r.timestamp != nil {
		localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLiquidityMiningUserHistoryV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	accountId  *int64
	markets    *string
	start      *int64
	end        *int64
}

func (r ApiGetLiquidityMiningUserHistoryV3Request) AccountId(accountId int64) ApiGetLiquidityMiningUserHistoryV3Request {
	r.accountId = &accountId
	return r
}

func (r ApiGetLiquidityMiningUserHistoryV3Request) Markets(markets string) ApiGetLiquidityMiningUserHistoryV3Request {
	r.markets = &markets
	return r
}

func (r ApiGetLiquidityMiningUserHistoryV3Request) Start(start int64) ApiGetLiquidityMiningUserHistoryV3Request {
	r.start = &start
	return r
}

func (r ApiGetLiquidityMiningUserHistoryV3Request) End(end int64) ApiGetLiquidityMiningUserHistoryV3Request {
	r.end = &end
	return r
}

func (r ApiGetLiquidityMiningUserHistoryV3Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetLiquidityMiningUserHistoryV3Execute(r)
}

/*
GetLiquidityMiningUserHistoryV3 Method for GetLiquidityMiningUserHistoryV3

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetLiquidityMiningUserHistoryV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetLiquidityMiningUserHistoryV3(ctx context.Context) ApiGetLiquidityMiningUserHistoryV3Request {
	return ApiGetLiquidityMiningUserHistoryV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *LoopringDEXRestfulAPIApiService) GetLiquidityMiningUserHistoryV3Execute(r ApiGetLiquidityMiningUserHistoryV3Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetLiquidityMiningUserHistoryV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/sidecar/liquidityMiningUserHistory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.accountId != nil {
		localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	}
	if r.markets != nil {
		localVarQueryParams.Add("markets", parameterToString(*r.markets, ""))
	}
	if r.start != nil {
		localVarQueryParams.Add("start", parameterToString(*r.start, ""))
	}
	if r.end != nil {
		localVarQueryParams.Add("end", parameterToString(*r.end, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLuckyTokenAgentsV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
}

func (r ApiGetLuckyTokenAgentsV3Request) Execute() (*GetLuckyTokenAgentsResponse, *http.Response, error) {
	return r.ApiService.GetLuckyTokenAgentsV3Execute(r)
}

/*
GetLuckyTokenAgentsV3 api.getLuckyTokenAgents.value

api.getLuckyTokenAgents.notes

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetLuckyTokenAgentsV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetLuckyTokenAgentsV3(ctx context.Context) ApiGetLuckyTokenAgentsV3Request {
	return ApiGetLuckyTokenAgentsV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GetLuckyTokenAgentsResponse
func (a *LoopringDEXRestfulAPIApiService) GetLuckyTokenAgentsV3Execute(r ApiGetLuckyTokenAgentsV3Request) (*GetLuckyTokenAgentsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetLuckyTokenAgentsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetLuckyTokenAgentsV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/luckyToken/agents"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLuckyTokenSignersV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
}

func (r ApiGetLuckyTokenSignersV3Request) Execute() (*GetLuckyTokenAgentsResponse, *http.Response, error) {
	return r.ApiService.GetLuckyTokenSignersV3Execute(r)
}

/*
GetLuckyTokenSignersV3 api.getLuckyTokenSigners.value

api.getLuckyTokenSigners.notes

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetLuckyTokenSignersV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetLuckyTokenSignersV3(ctx context.Context) ApiGetLuckyTokenSignersV3Request {
	return ApiGetLuckyTokenSignersV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GetLuckyTokenAgentsResponse
func (a *LoopringDEXRestfulAPIApiService) GetLuckyTokenSignersV3Execute(r ApiGetLuckyTokenSignersV3Request) (*GetLuckyTokenAgentsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetLuckyTokenAgentsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetLuckyTokenSignersV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/luckyToken/authorizedSigners"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLuckyTokenSummaryV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
}

func (r ApiGetLuckyTokenSummaryV3Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetLuckyTokenSummaryV3Execute(r)
}

/*
GetLuckyTokenSummaryV3 Method for GetLuckyTokenSummaryV3

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetLuckyTokenSummaryV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetLuckyTokenSummaryV3(ctx context.Context) ApiGetLuckyTokenSummaryV3Request {
	return ApiGetLuckyTokenSummaryV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *LoopringDEXRestfulAPIApiService) GetLuckyTokenSummaryV3Execute(r ApiGetLuckyTokenSummaryV3Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetLuckyTokenSummaryV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/luckyToken/user/summary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLuckyTokenUserBalancesV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	accountId  *int32
	tokens     *string
}

// AccountID
func (r ApiGetLuckyTokenUserBalancesV3Request) AccountId(accountId int32) ApiGetLuckyTokenUserBalancesV3Request {
	r.accountId = &accountId
	return r
}

// Query tokens
func (r ApiGetLuckyTokenUserBalancesV3Request) Tokens(tokens string) ApiGetLuckyTokenUserBalancesV3Request {
	r.tokens = &tokens
	return r
}

func (r ApiGetLuckyTokenUserBalancesV3Request) Execute() (*BalanceV3, *http.Response, error) {
	return r.ApiService.GetLuckyTokenUserBalancesV3Execute(r)
}

/*
GetLuckyTokenUserBalancesV3 api.getLuckyTokenBalance.value

api.getLuckyTokenBalance.notes

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetLuckyTokenUserBalancesV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetLuckyTokenUserBalancesV3(ctx context.Context) ApiGetLuckyTokenUserBalancesV3Request {
	return ApiGetLuckyTokenUserBalancesV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return BalanceV3
func (a *LoopringDEXRestfulAPIApiService) GetLuckyTokenUserBalancesV3Execute(r ApiGetLuckyTokenUserBalancesV3Request) (*BalanceV3, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BalanceV3
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetLuckyTokenUserBalancesV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/luckyToken/user/balances"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}

	localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	if r.tokens != nil {
		localVarQueryParams.Add("tokens", parameterToString(*r.tokens, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLuckyTokenV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	senderId   *int64
	hash       *string
	partitions *string
	nodes      *string
	scopes     *string
	statuses   *string
	startTime  *int64
	endTime    *int64
	fromId     *int64
	limit      *int32
	official   *bool
}

func (r ApiGetLuckyTokenV3Request) SenderId(senderId int64) ApiGetLuckyTokenV3Request {
	r.senderId = &senderId
	return r
}

func (r ApiGetLuckyTokenV3Request) Hash(hash string) ApiGetLuckyTokenV3Request {
	r.hash = &hash
	return r
}

func (r ApiGetLuckyTokenV3Request) Partitions(partitions string) ApiGetLuckyTokenV3Request {
	r.partitions = &partitions
	return r
}

func (r ApiGetLuckyTokenV3Request) Nodes(nodes string) ApiGetLuckyTokenV3Request {
	r.nodes = &nodes
	return r
}

func (r ApiGetLuckyTokenV3Request) Scopes(scopes string) ApiGetLuckyTokenV3Request {
	r.scopes = &scopes
	return r
}

func (r ApiGetLuckyTokenV3Request) Statuses(statuses string) ApiGetLuckyTokenV3Request {
	r.statuses = &statuses
	return r
}

func (r ApiGetLuckyTokenV3Request) StartTime(startTime int64) ApiGetLuckyTokenV3Request {
	r.startTime = &startTime
	return r
}

func (r ApiGetLuckyTokenV3Request) EndTime(endTime int64) ApiGetLuckyTokenV3Request {
	r.endTime = &endTime
	return r
}

func (r ApiGetLuckyTokenV3Request) FromId(fromId int64) ApiGetLuckyTokenV3Request {
	r.fromId = &fromId
	return r
}

func (r ApiGetLuckyTokenV3Request) Limit(limit int32) ApiGetLuckyTokenV3Request {
	r.limit = &limit
	return r
}

func (r ApiGetLuckyTokenV3Request) Official(official bool) ApiGetLuckyTokenV3Request {
	r.official = &official
	return r
}

func (r ApiGetLuckyTokenV3Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetLuckyTokenV3Execute(r)
}

/*
GetLuckyTokenV3 Method for GetLuckyTokenV3

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetLuckyTokenV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetLuckyTokenV3(ctx context.Context) ApiGetLuckyTokenV3Request {
	return ApiGetLuckyTokenV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *LoopringDEXRestfulAPIApiService) GetLuckyTokenV3Execute(r ApiGetLuckyTokenV3Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetLuckyTokenV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/luckyToken/user/luckyTokens"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.senderId != nil {
		localVarQueryParams.Add("senderId", parameterToString(*r.senderId, ""))
	}
	if r.hash != nil {
		localVarQueryParams.Add("hash", parameterToString(*r.hash, ""))
	}
	if r.partitions != nil {
		localVarQueryParams.Add("partitions", parameterToString(*r.partitions, ""))
	}
	if r.nodes != nil {
		localVarQueryParams.Add("nodes", parameterToString(*r.nodes, ""))
	}
	if r.scopes != nil {
		localVarQueryParams.Add("scopes", parameterToString(*r.scopes, ""))
	}
	if r.statuses != nil {
		localVarQueryParams.Add("statuses", parameterToString(*r.statuses, ""))
	}
	if r.startTime != nil {
		localVarQueryParams.Add("startTime", parameterToString(*r.startTime, ""))
	}
	if r.endTime != nil {
		localVarQueryParams.Add("endTime", parameterToString(*r.endTime, ""))
	}
	if r.fromId != nil {
		localVarQueryParams.Add("fromId", parameterToString(*r.fromId, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.official != nil {
		localVarQueryParams.Add("official", parameterToString(*r.official, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLuckyTokenWithdrawV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	statuses   *string
	tokenId    *int32
	startTime  *int64
	endTime    *int64
	fromId     *int64
	limit      *int32
}

func (r ApiGetLuckyTokenWithdrawV3Request) Statuses(statuses string) ApiGetLuckyTokenWithdrawV3Request {
	r.statuses = &statuses
	return r
}

func (r ApiGetLuckyTokenWithdrawV3Request) TokenId(tokenId int32) ApiGetLuckyTokenWithdrawV3Request {
	r.tokenId = &tokenId
	return r
}

func (r ApiGetLuckyTokenWithdrawV3Request) StartTime(startTime int64) ApiGetLuckyTokenWithdrawV3Request {
	r.startTime = &startTime
	return r
}

func (r ApiGetLuckyTokenWithdrawV3Request) EndTime(endTime int64) ApiGetLuckyTokenWithdrawV3Request {
	r.endTime = &endTime
	return r
}

func (r ApiGetLuckyTokenWithdrawV3Request) FromId(fromId int64) ApiGetLuckyTokenWithdrawV3Request {
	r.fromId = &fromId
	return r
}

func (r ApiGetLuckyTokenWithdrawV3Request) Limit(limit int32) ApiGetLuckyTokenWithdrawV3Request {
	r.limit = &limit
	return r
}

func (r ApiGetLuckyTokenWithdrawV3Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetLuckyTokenWithdrawV3Execute(r)
}

/*
GetLuckyTokenWithdrawV3 Method for GetLuckyTokenWithdrawV3

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetLuckyTokenWithdrawV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetLuckyTokenWithdrawV3(ctx context.Context) ApiGetLuckyTokenWithdrawV3Request {
	return ApiGetLuckyTokenWithdrawV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *LoopringDEXRestfulAPIApiService) GetLuckyTokenWithdrawV3Execute(r ApiGetLuckyTokenWithdrawV3Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetLuckyTokenWithdrawV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/luckyToken/user/withdraws"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.statuses != nil {
		localVarQueryParams.Add("statuses", parameterToString(*r.statuses, ""))
	}
	if r.tokenId != nil {
		localVarQueryParams.Add("tokenId", parameterToString(*r.tokenId, ""))
	}
	if r.startTime != nil {
		localVarQueryParams.Add("startTime", parameterToString(*r.startTime, ""))
	}
	if r.endTime != nil {
		localVarQueryParams.Add("endTime", parameterToString(*r.endTime, ""))
	}
	if r.fromId != nil {
		localVarQueryParams.Add("fromId", parameterToString(*r.fromId, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMarketTradeV2Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	market     *string
	limit      *int32
}

// Single market to query
func (r ApiGetMarketTradeV2Request) Market(market string) ApiGetMarketTradeV2Request {
	r.market = &market
	return r
}

// Number of queries
func (r ApiGetMarketTradeV2Request) Limit(limit int32) ApiGetMarketTradeV2Request {
	r.limit = &limit
	return r
}

func (r ApiGetMarketTradeV2Request) Execute() (*GetMarketTradesV2Response, *http.Response, error) {
	return r.ApiService.GetMarketTradeV2Execute(r)
}

/*
GetMarketTradeV2 Get market recent trades

Query trades with specified market

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMarketTradeV2Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetMarketTradeV2(ctx context.Context) ApiGetMarketTradeV2Request {
	return ApiGetMarketTradeV2Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GetMarketTradesV2Response
func (a *LoopringDEXRestfulAPIApiService) GetMarketTradeV2Execute(r ApiGetMarketTradeV2Request) (*GetMarketTradesV2Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetMarketTradesV2Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetMarketTradeV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/trade"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.market == nil {
		return localVarReturnValue, nil, reportError("market is required and must be specified")
	}

	localVarQueryParams.Add("market", parameterToString(*r.market, ""))
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMarketTradeV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	market     *string
	limit      *int32
	fillTypes  *string
}

// Single market to query
func (r ApiGetMarketTradeV3Request) Market(market string) ApiGetMarketTradeV3Request {
	r.market = &market
	return r
}

// Number of queries
func (r ApiGetMarketTradeV3Request) Limit(limit int32) ApiGetMarketTradeV3Request {
	r.limit = &limit
	return r
}

// request.getUserTxs.fillTypes
func (r ApiGetMarketTradeV3Request) FillTypes(fillTypes string) ApiGetMarketTradeV3Request {
	r.fillTypes = &fillTypes
	return r
}

func (r ApiGetMarketTradeV3Request) Execute() (*MarketTradesV3, *http.Response, error) {
	return r.ApiService.GetMarketTradeV3Execute(r)
}

/*
GetMarketTradeV3 Get market recent trades

Query trades with specified market

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMarketTradeV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetMarketTradeV3(ctx context.Context) ApiGetMarketTradeV3Request {
	return ApiGetMarketTradeV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return MarketTradesV3
func (a *LoopringDEXRestfulAPIApiService) GetMarketTradeV3Execute(r ApiGetMarketTradeV3Request) (*MarketTradesV3, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MarketTradesV3
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetMarketTradeV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/trade"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.market == nil {
		return localVarReturnValue, nil, reportError("market is required and must be specified")
	}

	localVarQueryParams.Add("market", parameterToString(*r.market, ""))
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.fillTypes != nil {
		localVarQueryParams.Add("fillTypes", parameterToString(*r.fillTypes, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMarketsV2Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
}

func (r ApiGetMarketsV2Request) Execute() (*GetMarketInfoResponse, *http.Response, error) {
	return r.ApiService.GetMarketsV2Execute(r)
}

/*
GetMarketsV2 Get market configurations

Returns the configurations of all supported markets (trading pairs)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMarketsV2Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetMarketsV2(ctx context.Context) ApiGetMarketsV2Request {
	return ApiGetMarketsV2Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GetMarketInfoResponse
func (a *LoopringDEXRestfulAPIApiService) GetMarketsV2Execute(r ApiGetMarketsV2Request) (*GetMarketInfoResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetMarketInfoResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetMarketsV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/exchange/markets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMarketsV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
}

func (r ApiGetMarketsV3Request) Execute() (*GetMarketsResponseV3, *http.Response, error) {
	return r.ApiService.GetMarketsV3Execute(r)
}

/*
GetMarketsV3 Get market configurations

Returns the configurations of all supported markets (trading pairs)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMarketsV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetMarketsV3(ctx context.Context) ApiGetMarketsV3Request {
	return ApiGetMarketsV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GetMarketsResponseV3
func (a *LoopringDEXRestfulAPIApiService) GetMarketsV3Execute(r ApiGetMarketsV3Request) (*GetMarketsResponseV3, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetMarketsResponseV3
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetMarketsV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/exchange/markets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMixedCandlestickV2Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	market     *string
	interval   *string
	start      *int64
	end        *int64
	limit      *int32
}

// Trading pair ID, multi-market is not supported
func (r ApiGetMixedCandlestickV2Request) Market(market string) ApiGetMixedCandlestickV2Request {
	r.market = &market
	return r
}

// Candlestick interval, Supported values are: 1min, 5min, 15min, 30min, 1hr, 2hr, 4hr, 12hr, 1d, 1w
func (r ApiGetMixedCandlestickV2Request) Interval(interval string) ApiGetMixedCandlestickV2Request {
	r.interval = &interval
	return r
}

// Start time
func (r ApiGetMixedCandlestickV2Request) Start(start int64) ApiGetMixedCandlestickV2Request {
	r.start = &start
	return r
}

// End time
func (r ApiGetMixedCandlestickV2Request) End(end int64) ApiGetMixedCandlestickV2Request {
	r.end = &end
	return r
}

// Number of data points. If more data points are available, the API will only return the first &#39;limit&#39; data points.
func (r ApiGetMixedCandlestickV2Request) Limit(limit int32) ApiGetMixedCandlestickV2Request {
	r.limit = &limit
	return r
}

func (r ApiGetMixedCandlestickV2Request) Execute() (*GetCandlestickResponseV2, *http.Response, error) {
	return r.ApiService.GetMixedCandlestickV2Execute(r)
}

/*
GetMixedCandlestickV2 Get market candlestick

Return the candlestick data of a given trading pair.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMixedCandlestickV2Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetMixedCandlestickV2(ctx context.Context) ApiGetMixedCandlestickV2Request {
	return ApiGetMixedCandlestickV2Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GetCandlestickResponseV2
func (a *LoopringDEXRestfulAPIApiService) GetMixedCandlestickV2Execute(r ApiGetMixedCandlestickV2Request) (*GetCandlestickResponseV2, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetCandlestickResponseV2
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetMixedCandlestickV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/mix/candlestick"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.market == nil {
		return localVarReturnValue, nil, reportError("market is required and must be specified")
	}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	localVarQueryParams.Add("market", parameterToString(*r.market, ""))
	localVarQueryParams.Add("interval", parameterToString(*r.interval, ""))
	if r.start != nil {
		localVarQueryParams.Add("start", parameterToString(*r.start, ""))
	}
	if r.end != nil {
		localVarQueryParams.Add("end", parameterToString(*r.end, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMixedCandlestickV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	market     *string
	interval   *string
	start      *int64
	end        *int64
	limit      *int32
}

// Trading pair ID, multi-market is not supported
func (r ApiGetMixedCandlestickV3Request) Market(market string) ApiGetMixedCandlestickV3Request {
	r.market = &market
	return r
}

// Candlestick interval, Supported values are: 1min, 5min, 15min, 30min, 1hr, 2hr, 4hr, 12hr, 1d, 1w
func (r ApiGetMixedCandlestickV3Request) Interval(interval string) ApiGetMixedCandlestickV3Request {
	r.interval = &interval
	return r
}

// Start time
func (r ApiGetMixedCandlestickV3Request) Start(start int64) ApiGetMixedCandlestickV3Request {
	r.start = &start
	return r
}

// End time
func (r ApiGetMixedCandlestickV3Request) End(end int64) ApiGetMixedCandlestickV3Request {
	r.end = &end
	return r
}

// Number of data points. If more data points are available, the API will only return the first &#39;limit&#39; data points.
func (r ApiGetMixedCandlestickV3Request) Limit(limit int32) ApiGetMixedCandlestickV3Request {
	r.limit = &limit
	return r
}

func (r ApiGetMixedCandlestickV3Request) Execute() (*GetCandlestickResponseV3, *http.Response, error) {
	return r.ApiService.GetMixedCandlestickV3Execute(r)
}

/*
GetMixedCandlestickV3 Get mixed market candlestick

Return the candlestick data of a given trading pair.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMixedCandlestickV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetMixedCandlestickV3(ctx context.Context) ApiGetMixedCandlestickV3Request {
	return ApiGetMixedCandlestickV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GetCandlestickResponseV3
func (a *LoopringDEXRestfulAPIApiService) GetMixedCandlestickV3Execute(r ApiGetMixedCandlestickV3Request) (*GetCandlestickResponseV3, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetCandlestickResponseV3
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetMixedCandlestickV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/mix/candlestick"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.market == nil {
		return localVarReturnValue, nil, reportError("market is required and must be specified")
	}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	localVarQueryParams.Add("market", parameterToString(*r.market, ""))
	localVarQueryParams.Add("interval", parameterToString(*r.interval, ""))
	if r.start != nil {
		localVarQueryParams.Add("start", parameterToString(*r.start, ""))
	}
	if r.end != nil {
		localVarQueryParams.Add("end", parameterToString(*r.end, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMixedDepthV2Request struct {
	ctx         context.Context
	ApiService  *LoopringDEXRestfulAPIApiService
	market      *string
	level       *int32
	limit       *int32
	showOverlap *bool
}

// The ID of a trading pair.
func (r ApiGetMixedDepthV2Request) Market(market string) ApiGetMixedDepthV2Request {
	r.market = &market
	return r
}

// Order book aggregation level, larger value means further price aggregation.
func (r ApiGetMixedDepthV2Request) Level(level int32) ApiGetMixedDepthV2Request {
	r.level = &level
	return r
}

// Maximum numbers of bids/asks.
func (r ApiGetMixedDepthV2Request) Limit(limit int32) ApiGetMixedDepthV2Request {
	r.limit = &limit
	return r
}

// request.getDepth.showOverlap
func (r ApiGetMixedDepthV2Request) ShowOverlap(showOverlap bool) ApiGetMixedDepthV2Request {
	r.showOverlap = &showOverlap
	return r
}

func (r ApiGetMixedDepthV2Request) Execute() (*GetDepthResponseV2, *http.Response, error) {
	return r.ApiService.GetMixedDepthV2Execute(r)
}

/*
GetMixedDepthV2 Get market orderbook

Returns the order book of a given trading pair.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMixedDepthV2Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetMixedDepthV2(ctx context.Context) ApiGetMixedDepthV2Request {
	return ApiGetMixedDepthV2Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GetDepthResponseV2
func (a *LoopringDEXRestfulAPIApiService) GetMixedDepthV2Execute(r ApiGetMixedDepthV2Request) (*GetDepthResponseV2, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetDepthResponseV2
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetMixedDepthV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/mix/depth"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.market == nil {
		return localVarReturnValue, nil, reportError("market is required and must be specified")
	}
	if r.level == nil {
		return localVarReturnValue, nil, reportError("level is required and must be specified")
	}

	localVarQueryParams.Add("market", parameterToString(*r.market, ""))
	localVarQueryParams.Add("level", parameterToString(*r.level, ""))
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.showOverlap != nil {
		localVarQueryParams.Add("showOverlap", parameterToString(*r.showOverlap, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMixedDepthV3Request struct {
	ctx         context.Context
	ApiService  *LoopringDEXRestfulAPIApiService
	market      *string
	level       *int32
	limit       *int32
	showOverlap *bool
}

// The ID of a trading pair.
func (r ApiGetMixedDepthV3Request) Market(market string) ApiGetMixedDepthV3Request {
	r.market = &market
	return r
}

// Order book aggregation level, larger value means further price aggregation.
func (r ApiGetMixedDepthV3Request) Level(level int32) ApiGetMixedDepthV3Request {
	r.level = &level
	return r
}

// Maximum numbers of bids/asks.
func (r ApiGetMixedDepthV3Request) Limit(limit int32) ApiGetMixedDepthV3Request {
	r.limit = &limit
	return r
}

// request.getDepth.showOverlap
func (r ApiGetMixedDepthV3Request) ShowOverlap(showOverlap bool) ApiGetMixedDepthV3Request {
	r.showOverlap = &showOverlap
	return r
}

func (r ApiGetMixedDepthV3Request) Execute() (*DepthV3, *http.Response, error) {
	return r.ApiService.GetMixedDepthV3Execute(r)
}

/*
GetMixedDepthV3 Get mixed market orderbook

Returns the order book of a given trading pair.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMixedDepthV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetMixedDepthV3(ctx context.Context) ApiGetMixedDepthV3Request {
	return ApiGetMixedDepthV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return DepthV3
func (a *LoopringDEXRestfulAPIApiService) GetMixedDepthV3Execute(r ApiGetMixedDepthV3Request) (*DepthV3, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DepthV3
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetMixedDepthV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/mix/depth"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.market == nil {
		return localVarReturnValue, nil, reportError("market is required and must be specified")
	}
	if r.level == nil {
		return localVarReturnValue, nil, reportError("level is required and must be specified")
	}

	localVarQueryParams.Add("market", parameterToString(*r.market, ""))
	localVarQueryParams.Add("level", parameterToString(*r.level, ""))
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.showOverlap != nil {
		localVarQueryParams.Add("showOverlap", parameterToString(*r.showOverlap, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMixedMarketsV2Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
}

func (r ApiGetMixedMarketsV2Request) Execute() (*GetMixedMarketInfoResponse, *http.Response, error) {
	return r.ApiService.GetMixedMarketsV2Execute(r)
}

/*
GetMixedMarketsV2 Get market configurations

Returns the configurations of all supported markets (trading pairs)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMixedMarketsV2Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetMixedMarketsV2(ctx context.Context) ApiGetMixedMarketsV2Request {
	return ApiGetMixedMarketsV2Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GetMixedMarketInfoResponse
func (a *LoopringDEXRestfulAPIApiService) GetMixedMarketsV2Execute(r ApiGetMixedMarketsV2Request) (*GetMixedMarketInfoResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetMixedMarketInfoResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetMixedMarketsV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/mix/markets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMixedMarketsV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
}

func (r ApiGetMixedMarketsV3Request) Execute() (*GetMixedMarketsResponseV3, *http.Response, error) {
	return r.ApiService.GetMixedMarketsV3Execute(r)
}

/*
GetMixedMarketsV3 Get mixed market configurations

Returns the configurations of all supported markets (trading pairs)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMixedMarketsV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetMixedMarketsV3(ctx context.Context) ApiGetMixedMarketsV3Request {
	return ApiGetMixedMarketsV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GetMixedMarketsResponseV3
func (a *LoopringDEXRestfulAPIApiService) GetMixedMarketsV3Execute(r ApiGetMixedMarketsV3Request) (*GetMixedMarketsResponseV3, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetMixedMarketsResponseV3
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetMixedMarketsV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/mix/markets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMixedTickerV2Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	market     *string
}

// Market pair, support multiple markets
func (r ApiGetMixedTickerV2Request) Market(market string) ApiGetMixedTickerV2Request {
	r.market = &market
	return r
}

func (r ApiGetMixedTickerV2Request) Execute() (*GetTickerResponseV2, *http.Response, error) {
	return r.ApiService.GetMixedTickerV2Execute(r)
}

/*
GetMixedTickerV2 Get market ticker

Gets a markets ticker. Generally speaking, a ticker in Loopring consists in data from the market taken last 24Hours.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMixedTickerV2Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetMixedTickerV2(ctx context.Context) ApiGetMixedTickerV2Request {
	return ApiGetMixedTickerV2Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GetTickerResponseV2
func (a *LoopringDEXRestfulAPIApiService) GetMixedTickerV2Execute(r ApiGetMixedTickerV2Request) (*GetTickerResponseV2, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetTickerResponseV2
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetMixedTickerV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/mix/ticker"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.market == nil {
		return localVarReturnValue, nil, reportError("market is required and must be specified")
	}

	localVarQueryParams.Add("market", parameterToString(*r.market, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMixedTickerV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	market     *string
}

// Market pair, support multiple markets
func (r ApiGetMixedTickerV3Request) Market(market string) ApiGetMixedTickerV3Request {
	r.market = &market
	return r
}

func (r ApiGetMixedTickerV3Request) Execute() (*GetTickerResponseV3, *http.Response, error) {
	return r.ApiService.GetMixedTickerV3Execute(r)
}

/*
GetMixedTickerV3 Get mixed market ticker

Gets a markets ticker. Generally speaking, a ticker in Loopring consists in data from the market taken last 24Hours.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMixedTickerV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetMixedTickerV3(ctx context.Context) ApiGetMixedTickerV3Request {
	return ApiGetMixedTickerV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GetTickerResponseV3
func (a *LoopringDEXRestfulAPIApiService) GetMixedTickerV3Execute(r ApiGetMixedTickerV3Request) (*GetTickerResponseV3, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetTickerResponseV3
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetMixedTickerV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/mix/ticker"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.market == nil {
		return localVarReturnValue, nil, reportError("market is required and must be specified")
	}

	localVarQueryParams.Add("market", parameterToString(*r.market, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNewestTokenPricesV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	tokens     *string
	currency   *string
}

func (r ApiGetNewestTokenPricesV3Request) Tokens(tokens string) ApiGetNewestTokenPricesV3Request {
	r.tokens = &tokens
	return r
}

func (r ApiGetNewestTokenPricesV3Request) Currency(currency string) ApiGetNewestTokenPricesV3Request {
	r.currency = &currency
	return r
}

func (r ApiGetNewestTokenPricesV3Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetNewestTokenPricesV3Execute(r)
}

/*
GetNewestTokenPricesV3 Method for GetNewestTokenPricesV3

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetNewestTokenPricesV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetNewestTokenPricesV3(ctx context.Context) ApiGetNewestTokenPricesV3Request {
	return ApiGetNewestTokenPricesV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *LoopringDEXRestfulAPIApiService) GetNewestTokenPricesV3Execute(r ApiGetNewestTokenPricesV3Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetNewestTokenPricesV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/datacenter/getNewestTokenPrices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.tokens != nil {
		localVarQueryParams.Add("tokens", parameterToString(*r.tokens, ""))
	}
	if r.currency != nil {
		localVarQueryParams.Add("currency", parameterToString(*r.currency, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNextStorageIdV2Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	accountId  *int64
	tokenSId   *int32
}

// Looprings account identifier
func (r ApiGetNextStorageIdV2Request) AccountId(accountId int64) ApiGetNextStorageIdV2Request {
	r.accountId = &accountId
	return r
}

// request.getNextStorageId.tokenSId
func (r ApiGetNextStorageIdV2Request) TokenSId(tokenSId int32) ApiGetNextStorageIdV2Request {
	r.tokenSId = &tokenSId
	return r
}

func (r ApiGetNextStorageIdV2Request) Execute() (*GetNextStorageIdResponseData, *http.Response, error) {
	return r.ApiService.GetNextStorageIdV2Execute(r)
}

/*
GetNextStorageIdV2 Get next storage ID

Fetches the next order id for a given sold token. If the need arises to repeatedly place orders in a short span of time, the order id can be initially fetched through the API and then managed locally. Each new order id can be derived from adding 2 to the last one

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetNextStorageIdV2Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetNextStorageIdV2(ctx context.Context) ApiGetNextStorageIdV2Request {
	return ApiGetNextStorageIdV2Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GetNextStorageIdResponseData
func (a *LoopringDEXRestfulAPIApiService) GetNextStorageIdV2Execute(r ApiGetNextStorageIdV2Request) (*GetNextStorageIdResponseData, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetNextStorageIdResponseData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetNextStorageIdV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/storageId"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.tokenSId == nil {
		return localVarReturnValue, nil, reportError("tokenSId is required and must be specified")
	}

	localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	localVarQueryParams.Add("tokenSId", parameterToString(*r.tokenSId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNextStorageIdV3Request struct {
	ctx         context.Context
	ApiService  *LoopringDEXRestfulAPIApiService
	accountId   *int64
	sellTokenId *int32
	maxNext     *bool
}

// Looprings account identifier
func (r ApiGetNextStorageIdV3Request) AccountId(accountId int64) ApiGetNextStorageIdV3Request {
	r.accountId = &accountId
	return r
}

// The unique identifier of the token which the user wants to sell in the next order.
func (r ApiGetNextStorageIdV3Request) SellTokenId(sellTokenId int32) ApiGetNextStorageIdV3Request {
	r.sellTokenId = &sellTokenId
	return r
}

// Return the max of the next available storageId, so any storageId &gt; returned value is avaliable, to help user manage storageId by themselves. for example, if [20, 60, 100] is avaliable, all other ids &lt; 100 is used before, user gets 20 if flag is false (and 60 in next run), but gets 100 if flag is true, so he can use 102, 104 freely
func (r ApiGetNextStorageIdV3Request) MaxNext(maxNext bool) ApiGetNextStorageIdV3Request {
	r.maxNext = &maxNext
	return r
}

func (r ApiGetNextStorageIdV3Request) Execute() (*NextStorageIdResponse, *http.Response, error) {
	return r.ApiService.GetNextStorageIdV3Execute(r)
}

/*
GetNextStorageIdV3 Get next storage ID

Fetches the next order id for a given sold token. If the need arises to repeatedly place orders in a short span of time, the order id can be initially fetched through the API and then managed locally. Each new order id can be derived from adding 2 to the last one

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetNextStorageIdV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetNextStorageIdV3(ctx context.Context) ApiGetNextStorageIdV3Request {
	return ApiGetNextStorageIdV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return NextStorageIdResponse
func (a *LoopringDEXRestfulAPIApiService) GetNextStorageIdV3Execute(r ApiGetNextStorageIdV3Request) (*NextStorageIdResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *NextStorageIdResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetNextStorageIdV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/storageId"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.sellTokenId == nil {
		return localVarReturnValue, nil, reportError("sellTokenId is required and must be specified")
	}

	localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	localVarQueryParams.Add("sellTokenId", parameterToString(*r.sellTokenId, ""))
	if r.maxNext != nil {
		localVarQueryParams.Add("maxNext", parameterToString(*r.maxNext, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNftDataV3Request struct {
	ctx          context.Context
	ApiService   *LoopringDEXRestfulAPIApiService
	minter       *string
	tokenAddress *string
	nftId        *string
}

// The minters accountId.
func (r ApiGetNftDataV3Request) Minter(minter string) ApiGetNftDataV3Request {
	r.minter = &minter
	return r
}

// The NFT token address
func (r ApiGetNftDataV3Request) TokenAddress(tokenAddress string) ApiGetNftDataV3Request {
	r.tokenAddress = &tokenAddress
	return r
}

// The NFT_ID of the NFT token
func (r ApiGetNftDataV3Request) NftId(nftId string) ApiGetNftDataV3Request {
	r.nftId = &nftId
	return r
}

func (r ApiGetNftDataV3Request) Execute() (*NftTokenInfo, *http.Response, error) {
	return r.ApiService.GetNftDataV3Execute(r)
}

/*
GetNftDataV3 Query nftDatas by minter, tokenAddress and nftID.

Query nftDatas by minter, tokenAddress and nftID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetNftDataV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetNftDataV3(ctx context.Context) ApiGetNftDataV3Request {
	return ApiGetNftDataV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return NftTokenInfo
func (a *LoopringDEXRestfulAPIApiService) GetNftDataV3Execute(r ApiGetNftDataV3Request) (*NftTokenInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *NftTokenInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetNftDataV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/nft/info/nftData"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.minter == nil {
		return localVarReturnValue, nil, reportError("minter is required and must be specified")
	}
	if r.tokenAddress == nil {
		return localVarReturnValue, nil, reportError("tokenAddress is required and must be specified")
	}
	if r.nftId == nil {
		return localVarReturnValue, nil, reportError("nftId is required and must be specified")
	}

	localVarQueryParams.Add("minter", parameterToString(*r.minter, ""))
	localVarQueryParams.Add("tokenAddress", parameterToString(*r.tokenAddress, ""))
	localVarQueryParams.Add("nftId", parameterToString(*r.nftId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNftDepositsV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	accountId  *int64
	nftData    *string
	start      *int64
	end        *int64
	startId    *int64
	limit      *int32
	txStatus   *string
	hashes     *string
}

// users accountId.
func (r ApiGetNftDepositsV3Request) AccountId(accountId int64) ApiGetNftDepositsV3Request {
	r.accountId = &accountId
	return r
}

// the nftData of the NFT token
func (r ApiGetNftDepositsV3Request) NftData(nftData string) ApiGetNftDepositsV3Request {
	r.nftData = &nftData
	return r
}

// Start time in milliseconds
func (r ApiGetNftDepositsV3Request) Start(start int64) ApiGetNftDepositsV3Request {
	r.start = &start
	return r
}

// End time in milliseconds
func (r ApiGetNftDepositsV3Request) End(end int64) ApiGetNftDepositsV3Request {
	r.end = &end
	return r
}

// The begin id of the query.
func (r ApiGetNftDepositsV3Request) StartId(startId int64) ApiGetNftDepositsV3Request {
	r.startId = &startId
	return r
}

// Number of records to return
func (r ApiGetNftDepositsV3Request) Limit(limit int32) ApiGetNftDepositsV3Request {
	r.limit = &limit
	return r
}

// The deposit status
func (r ApiGetNftDepositsV3Request) TxStatus(txStatus string) ApiGetNftDepositsV3Request {
	r.txStatus = &txStatus
	return r
}

// The hashes (split by ,) of the transactions, normally its L2 tx hash, except the deposit which uses L1 tx hash.
func (r ApiGetNftDepositsV3Request) Hashes(hashes string) ApiGetNftDepositsV3Request {
	r.hashes = &hashes
	return r
}

func (r ApiGetNftDepositsV3Request) Execute() (*GetUserNftDepositResponse, *http.Response, error) {
	return r.ApiService.GetNftDepositsV3Execute(r)
}

/*
GetNftDepositsV3 Get user NFT deposit history

Returns a list of NFT deposit records for the given user.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetNftDepositsV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetNftDepositsV3(ctx context.Context) ApiGetNftDepositsV3Request {
	return ApiGetNftDepositsV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GetUserNftDepositResponse
func (a *LoopringDEXRestfulAPIApiService) GetNftDepositsV3Execute(r ApiGetNftDepositsV3Request) (*GetUserNftDepositResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetUserNftDepositResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetNftDepositsV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/user/nft/deposits"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}

	localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	if r.nftData != nil {
		localVarQueryParams.Add("nftData", parameterToString(*r.nftData, ""))
	}
	if r.start != nil {
		localVarQueryParams.Add("start", parameterToString(*r.start, ""))
	}
	if r.end != nil {
		localVarQueryParams.Add("end", parameterToString(*r.end, ""))
	}
	if r.startId != nil {
		localVarQueryParams.Add("startId", parameterToString(*r.startId, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.txStatus != nil {
		localVarQueryParams.Add("txStatus", parameterToString(*r.txStatus, ""))
	}
	if r.hashes != nil {
		localVarQueryParams.Add("hashes", parameterToString(*r.hashes, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNftHoldersV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	nftData    *string
	offset     *int32
	limit      *int32
}

// The Loopring&#39;s NFT token data identifier which is a hash string of NFT token address and NFT_ID
func (r ApiGetNftHoldersV3Request) NftData(nftData string) ApiGetNftHoldersV3Request {
	r.nftData = &nftData
	return r
}

// Number of records to skip
func (r ApiGetNftHoldersV3Request) Offset(offset int32) ApiGetNftHoldersV3Request {
	r.offset = &offset
	return r
}

// Number of records to return
func (r ApiGetNftHoldersV3Request) Limit(limit int32) ApiGetNftHoldersV3Request {
	r.limit = &limit
	return r
}

func (r ApiGetNftHoldersV3Request) Execute() (*NftHolders, *http.Response, error) {
	return r.ApiService.GetNftHoldersV3Execute(r)
}

/*
GetNftHoldersV3 Query NFT holders by looprings nftData

Query NFT holders by looprings nftData

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetNftHoldersV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetNftHoldersV3(ctx context.Context) ApiGetNftHoldersV3Request {
	return ApiGetNftHoldersV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return NftHolders
func (a *LoopringDEXRestfulAPIApiService) GetNftHoldersV3Execute(r ApiGetNftHoldersV3Request) (*NftHolders, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *NftHolders
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetNftHoldersV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/nft/info/nftHolders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.nftData == nil {
		return localVarReturnValue, nil, reportError("nftData is required and must be specified")
	}

	localVarQueryParams.Add("nftData", parameterToString(*r.nftData, ""))
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNftMintersV3Request struct {
	ctx                 context.Context
	ApiService          *LoopringDEXRestfulAPIApiService
	channel             *int32
	authContractAddress *string
}

// channel id, if you dont know your channel id, please contact with Loopring team.
func (r ApiGetNftMintersV3Request) Channel(channel int32) ApiGetNftMintersV3Request {
	r.channel = &channel
	return r
}

// auth contract address
func (r ApiGetNftMintersV3Request) AuthContractAddress(authContractAddress string) ApiGetNftMintersV3Request {
	r.authContractAddress = &authContractAddress
	return r
}

func (r ApiGetNftMintersV3Request) Execute() (*GetNftMintersResponse, *http.Response, error) {
	return r.ApiService.GetNftMintersV3Execute(r)
}

/*
GetNftMintersV3 Get minters

Filtered by channel and auth contract address

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetNftMintersV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetNftMintersV3(ctx context.Context) ApiGetNftMintersV3Request {
	return ApiGetNftMintersV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GetNftMintersResponse
func (a *LoopringDEXRestfulAPIApiService) GetNftMintersV3Execute(r ApiGetNftMintersV3Request) (*GetNftMintersResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetNftMintersResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetNftMintersV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/nft/info/minters"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.channel == nil {
		return localVarReturnValue, nil, reportError("channel is required and must be specified")
	}

	localVarQueryParams.Add("channel", parameterToString(*r.channel, ""))
	if r.authContractAddress != nil {
		localVarQueryParams.Add("authContractAddress", parameterToString(*r.authContractAddress, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNftOrderUserRateAmountV3Request struct {
	ctx             context.Context
	ApiService      *LoopringDEXRestfulAPIApiService
	accountId       *int64
	nftTokenAddress *string
	feeTokenSymbol  *string
}

// Account ID, some hash query APIs doesnt need it if in hash query mode, check require flag of each API to see if its a must.
func (r ApiGetNftOrderUserRateAmountV3Request) AccountId(accountId int64) ApiGetNftOrderUserRateAmountV3Request {
	r.accountId = &accountId
	return r
}

// NFT token address of order
func (r ApiGetNftOrderUserRateAmountV3Request) NftTokenAddress(nftTokenAddress string) ApiGetNftOrderUserRateAmountV3Request {
	r.nftTokenAddress = &nftTokenAddress
	return r
}

// Fee token symbol
func (r ApiGetNftOrderUserRateAmountV3Request) FeeTokenSymbol(feeTokenSymbol string) ApiGetNftOrderUserRateAmountV3Request {
	r.feeTokenSymbol = &feeTokenSymbol
	return r
}

func (r ApiGetNftOrderUserRateAmountV3Request) Execute() (*GetUserNftOrderRatesAmountsResponse, *http.Response, error) {
	return r.ApiService.GetNftOrderUserRateAmountV3Execute(r)
}

/*
GetNftOrderUserRateAmountV3 Query current token minimum amount to place order based on users VIP level and max fee bips

minAmount is the minFee under the basic feeRate of the user, tradeCosts is the cost of L2 trade settlement, also it returns the market order requirements: the min/max order amount. So an valid order should meet these 3 requirements:.1. order.maxFeeBips >= feeRate.rate and order.amount >= minAmounts.2. order.amount * order.maxFeeBips > tradeCosts if order.amount < minAmounts.3. marketOrderInfo.min <= order.amount <= marketOrderInfo.max.These amounts change according to ETH gas price and get refreshed every 15 mins.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetNftOrderUserRateAmountV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetNftOrderUserRateAmountV3(ctx context.Context) ApiGetNftOrderUserRateAmountV3Request {
	return ApiGetNftOrderUserRateAmountV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GetUserNftOrderRatesAmountsResponse
func (a *LoopringDEXRestfulAPIApiService) GetNftOrderUserRateAmountV3Execute(r ApiGetNftOrderUserRateAmountV3Request) (*GetUserNftOrderRatesAmountsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetUserNftOrderRatesAmountsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetNftOrderUserRateAmountV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/nft/info/orderUserRateAmount"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.nftTokenAddress == nil {
		return localVarReturnValue, nil, reportError("nftTokenAddress is required and must be specified")
	}

	localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	localVarQueryParams.Add("nftTokenAddress", parameterToString(*r.nftTokenAddress, ""))
	if r.feeTokenSymbol != nil {
		localVarQueryParams.Add("feeTokenSymbol", parameterToString(*r.feeTokenSymbol, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNftRequestFeesV3Request struct {
	ctx          context.Context
	ApiService   *LoopringDEXRestfulAPIApiService
	accountId    *int32
	requestType  *int32
	tokenAddress *string
	amount       *string
}

// Account ID
func (r ApiGetNftRequestFeesV3Request) AccountId(accountId int32) ApiGetNftRequestFeesV3Request {
	r.accountId = &accountId
	return r
}

// Off-chain request type
func (r ApiGetNftRequestFeesV3Request) RequestType(requestType int32) ApiGetNftRequestFeesV3Request {
	r.requestType = &requestType
	return r
}

// the NFT tokenAddress
func (r ApiGetNftRequestFeesV3Request) TokenAddress(tokenAddress string) ApiGetNftRequestFeesV3Request {
	r.tokenAddress = &tokenAddress
	return r
}

// The amount to withdraw
func (r ApiGetNftRequestFeesV3Request) Amount(amount string) ApiGetNftRequestFeesV3Request {
	r.amount = &amount
	return r
}

func (r ApiGetNftRequestFeesV3Request) Execute() (*OffFeeInfo2, *http.Response, error) {
	return r.ApiService.GetNftRequestFeesV3Execute(r)
}

/*
GetNftRequestFeesV3 Query current NFT requests fee amount

Returns the NFT requests fee amount

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetNftRequestFeesV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetNftRequestFeesV3(ctx context.Context) ApiGetNftRequestFeesV3Request {
	return ApiGetNftRequestFeesV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return OffFeeInfo2
func (a *LoopringDEXRestfulAPIApiService) GetNftRequestFeesV3Execute(r ApiGetNftRequestFeesV3Request) (*OffFeeInfo2, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *OffFeeInfo2
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetNftRequestFeesV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/user/nft/offchainFee"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.requestType == nil {
		return localVarReturnValue, nil, reportError("requestType is required and must be specified")
	}

	localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	localVarQueryParams.Add("requestType", parameterToString(*r.requestType, ""))
	if r.tokenAddress != nil {
		localVarQueryParams.Add("tokenAddress", parameterToString(*r.tokenAddress, ""))
	}
	if r.amount != nil {
		localVarQueryParams.Add("amount", parameterToString(*r.amount, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNftTokenAddressesV3Request struct {
	ctx                 context.Context
	ApiService          *LoopringDEXRestfulAPIApiService
	channel             *int32
	authContractAddress *string
	offset              *int64
	limit               *int32
}

// channel id, if you dont know your channel id, please contact with Loopring team.
func (r ApiGetNftTokenAddressesV3Request) Channel(channel int32) ApiGetNftTokenAddressesV3Request {
	r.channel = &channel
	return r
}

// auth contract address
func (r ApiGetNftTokenAddressesV3Request) AuthContractAddress(authContractAddress string) ApiGetNftTokenAddressesV3Request {
	r.authContractAddress = &authContractAddress
	return r
}

// amount to skip(default: 0)
func (r ApiGetNftTokenAddressesV3Request) Offset(offset int64) ApiGetNftTokenAddressesV3Request {
	r.offset = &offset
	return r
}

// Max amount of token addresses to return(default: 500)
func (r ApiGetNftTokenAddressesV3Request) Limit(limit int32) ApiGetNftTokenAddressesV3Request {
	r.limit = &limit
	return r
}

func (r ApiGetNftTokenAddressesV3Request) Execute() (*GetNftTokenAddressesResponse, *http.Response, error) {
	return r.ApiService.GetNftTokenAddressesV3Execute(r)
}

/*
GetNftTokenAddressesV3 Get Nft token addresses

Filtered by channel and auth contract address

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetNftTokenAddressesV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetNftTokenAddressesV3(ctx context.Context) ApiGetNftTokenAddressesV3Request {
	return ApiGetNftTokenAddressesV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GetNftTokenAddressesResponse
func (a *LoopringDEXRestfulAPIApiService) GetNftTokenAddressesV3Execute(r ApiGetNftTokenAddressesV3Request) (*GetNftTokenAddressesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetNftTokenAddressesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetNftTokenAddressesV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/nft/info/nftTokenAddresses"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.channel == nil {
		return localVarReturnValue, nil, reportError("channel is required and must be specified")
	}

	localVarQueryParams.Add("channel", parameterToString(*r.channel, ""))
	if r.authContractAddress != nil {
		localVarQueryParams.Add("authContractAddress", parameterToString(*r.authContractAddress, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNftTradesV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	accountId  *int64
	nftData    *string
	orderHash  *string
	start      *int64
	end        *int64
	startId    *int64
	limit      *int32
}

// users accountId.
func (r ApiGetNftTradesV3Request) AccountId(accountId int64) ApiGetNftTradesV3Request {
	r.accountId = &accountId
	return r
}

// the nftData of the NFT token
func (r ApiGetNftTradesV3Request) NftData(nftData string) ApiGetNftTradesV3Request {
	r.nftData = &nftData
	return r
}

// request.getNftTrades.orderHash
func (r ApiGetNftTradesV3Request) OrderHash(orderHash string) ApiGetNftTradesV3Request {
	r.orderHash = &orderHash
	return r
}

// request.getNftTrades.tradeHash
func (r ApiGetNftTradesV3Request) Start(start int64) ApiGetNftTradesV3Request {
	r.start = &start
	return r
}

// Start time in milliseconds
func (r ApiGetNftTradesV3Request) End(end int64) ApiGetNftTradesV3Request {
	r.end = &end
	return r
}

// End time in milliseconds
func (r ApiGetNftTradesV3Request) StartId(startId int64) ApiGetNftTradesV3Request {
	r.startId = &startId
	return r
}

// The begin id of the query.
func (r ApiGetNftTradesV3Request) Limit(limit int32) ApiGetNftTradesV3Request {
	r.limit = &limit
	return r
}

func (r ApiGetNftTradesV3Request) Execute() (*NftTradeList, *http.Response, error) {
	return r.ApiService.GetNftTradesV3Execute(r)
}

/*
GetNftTradesV3 Users Nft trade list

Users NFT trade list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetNftTradesV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetNftTradesV3(ctx context.Context) ApiGetNftTradesV3Request {
	return ApiGetNftTradesV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return NftTradeList
func (a *LoopringDEXRestfulAPIApiService) GetNftTradesV3Execute(r ApiGetNftTradesV3Request) (*NftTradeList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *NftTradeList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetNftTradesV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/user/nft/trades"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}

	localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	if r.nftData != nil {
		localVarQueryParams.Add("nftData", parameterToString(*r.nftData, ""))
	}
	if r.orderHash != nil {
		localVarQueryParams.Add("orderHash", parameterToString(*r.orderHash, ""))
	}
	if r.start != nil {
		localVarQueryParams.Add("start", parameterToString(*r.start, ""))
	}
	if r.end != nil {
		localVarQueryParams.Add("end", parameterToString(*r.end, ""))
	}
	if r.startId != nil {
		localVarQueryParams.Add("startId", parameterToString(*r.startId, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNftTransfersV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	accountId  *int64
	nftData    *string
	start      *int64
	end        *int64
	startId    *int64
	limit      *int32
	txStatus   *string
	hashes     *string
}

// users accountId.
func (r ApiGetNftTransfersV3Request) AccountId(accountId int64) ApiGetNftTransfersV3Request {
	r.accountId = &accountId
	return r
}

// the nftData of the NFT token
func (r ApiGetNftTransfersV3Request) NftData(nftData string) ApiGetNftTransfersV3Request {
	r.nftData = &nftData
	return r
}

// Start time in milliseconds
func (r ApiGetNftTransfersV3Request) Start(start int64) ApiGetNftTransfersV3Request {
	r.start = &start
	return r
}

// End time in milliseconds
func (r ApiGetNftTransfersV3Request) End(end int64) ApiGetNftTransfersV3Request {
	r.end = &end
	return r
}

// The begin id of the query.
func (r ApiGetNftTransfersV3Request) StartId(startId int64) ApiGetNftTransfersV3Request {
	r.startId = &startId
	return r
}

// Number of records to return
func (r ApiGetNftTransfersV3Request) Limit(limit int32) ApiGetNftTransfersV3Request {
	r.limit = &limit
	return r
}

// The transfer status
func (r ApiGetNftTransfersV3Request) TxStatus(txStatus string) ApiGetNftTransfersV3Request {
	r.txStatus = &txStatus
	return r
}

// The hashes (split by ,) of the transactions, normally its L2 tx hash, except the deposit which uses L1 tx hash.
func (r ApiGetNftTransfersV3Request) Hashes(hashes string) ApiGetNftTransfersV3Request {
	r.hashes = &hashes
	return r
}

func (r ApiGetNftTransfersV3Request) Execute() (*GetUserNftTransfersResponse, *http.Response, error) {
	return r.ApiService.GetNftTransfersV3Execute(r)
}

/*
GetNftTransfersV3 Get user NFT transfer history

Returns a list of NFT trade records for the given user.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetNftTransfersV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetNftTransfersV3(ctx context.Context) ApiGetNftTransfersV3Request {
	return ApiGetNftTransfersV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GetUserNftTransfersResponse
func (a *LoopringDEXRestfulAPIApiService) GetNftTransfersV3Execute(r ApiGetNftTransfersV3Request) (*GetUserNftTransfersResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetUserNftTransfersResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetNftTransfersV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/user/nft/transfers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}

	localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	if r.nftData != nil {
		localVarQueryParams.Add("nftData", parameterToString(*r.nftData, ""))
	}
	if r.start != nil {
		localVarQueryParams.Add("start", parameterToString(*r.start, ""))
	}
	if r.end != nil {
		localVarQueryParams.Add("end", parameterToString(*r.end, ""))
	}
	if r.startId != nil {
		localVarQueryParams.Add("startId", parameterToString(*r.startId, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.txStatus != nil {
		localVarQueryParams.Add("txStatus", parameterToString(*r.txStatus, ""))
	}
	if r.hashes != nil {
		localVarQueryParams.Add("hashes", parameterToString(*r.hashes, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNftWithdrawalsV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	accountId  *int64
	nftData    *string
	start      *int64
	end        *int64
	startId    *int64
	limit      *int32
	txStatus   *string
	hashes     *string
}

// users accountId.
func (r ApiGetNftWithdrawalsV3Request) AccountId(accountId int64) ApiGetNftWithdrawalsV3Request {
	r.accountId = &accountId
	return r
}

// the nftData of the NFT token
func (r ApiGetNftWithdrawalsV3Request) NftData(nftData string) ApiGetNftWithdrawalsV3Request {
	r.nftData = &nftData
	return r
}

// Start time in milliseconds
func (r ApiGetNftWithdrawalsV3Request) Start(start int64) ApiGetNftWithdrawalsV3Request {
	r.start = &start
	return r
}

// End time in milliseconds
func (r ApiGetNftWithdrawalsV3Request) End(end int64) ApiGetNftWithdrawalsV3Request {
	r.end = &end
	return r
}

// The begin id of the query.
func (r ApiGetNftWithdrawalsV3Request) StartId(startId int64) ApiGetNftWithdrawalsV3Request {
	r.startId = &startId
	return r
}

// Number of records to return
func (r ApiGetNftWithdrawalsV3Request) Limit(limit int32) ApiGetNftWithdrawalsV3Request {
	r.limit = &limit
	return r
}

// The withdrawal status
func (r ApiGetNftWithdrawalsV3Request) TxStatus(txStatus string) ApiGetNftWithdrawalsV3Request {
	r.txStatus = &txStatus
	return r
}

// The hashes (split by ,) of the transactions, normally its L2 tx hash, except the deposit which uses L1 tx hash.
func (r ApiGetNftWithdrawalsV3Request) Hashes(hashes string) ApiGetNftWithdrawalsV3Request {
	r.hashes = &hashes
	return r
}

func (r ApiGetNftWithdrawalsV3Request) Execute() (*GetUserNftWithdrawalResponse, *http.Response, error) {
	return r.ApiService.GetNftWithdrawalsV3Execute(r)
}

/*
GetNftWithdrawalsV3 Get user NFT withdraw history

Returns a list of NFT withdraw records for the given user.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetNftWithdrawalsV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetNftWithdrawalsV3(ctx context.Context) ApiGetNftWithdrawalsV3Request {
	return ApiGetNftWithdrawalsV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GetUserNftWithdrawalResponse
func (a *LoopringDEXRestfulAPIApiService) GetNftWithdrawalsV3Execute(r ApiGetNftWithdrawalsV3Request) (*GetUserNftWithdrawalResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetUserNftWithdrawalResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetNftWithdrawalsV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/user/nft/withdrawals"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}

	localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	if r.nftData != nil {
		localVarQueryParams.Add("nftData", parameterToString(*r.nftData, ""))
	}
	if r.start != nil {
		localVarQueryParams.Add("start", parameterToString(*r.start, ""))
	}
	if r.end != nil {
		localVarQueryParams.Add("end", parameterToString(*r.end, ""))
	}
	if r.startId != nil {
		localVarQueryParams.Add("startId", parameterToString(*r.startId, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.txStatus != nil {
		localVarQueryParams.Add("txStatus", parameterToString(*r.txStatus, ""))
	}
	if r.hashes != nil {
		localVarQueryParams.Add("hashes", parameterToString(*r.hashes, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNftsInfoV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	nftDatas   *string
}

// The Loopring&#39;s NFT token data identifier which is a hash string of NFT token address and NFT_ID
func (r ApiGetNftsInfoV3Request) NftDatas(nftDatas string) ApiGetNftsInfoV3Request {
	r.nftDatas = &nftDatas
	return r
}

func (r ApiGetNftsInfoV3Request) Execute() (*NftTokenInfo, *http.Response, error) {
	return r.ApiService.GetNftsInfoV3Execute(r)
}

/*
GetNftsInfoV3 Query NFT info by looprings nftData

Query NFT info by looprings nftData

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetNftsInfoV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetNftsInfoV3(ctx context.Context) ApiGetNftsInfoV3Request {
	return ApiGetNftsInfoV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return NftTokenInfo
func (a *LoopringDEXRestfulAPIApiService) GetNftsInfoV3Execute(r ApiGetNftsInfoV3Request) (*NftTokenInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *NftTokenInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetNftsInfoV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/nft/info/nfts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.nftDatas == nil {
		return localVarReturnValue, nil, reportError("nftDatas is required and must be specified")
	}

	localVarQueryParams.Add("nftDatas", parameterToString(*r.nftDatas, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNotWithdrawContractTokensV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
}

func (r ApiGetNotWithdrawContractTokensV3Request) Execute() (*TokenInfoV3, *http.Response, error) {
	return r.ApiService.GetNotWithdrawContractTokensV3Execute(r)
}

/*
GetNotWithdrawContractTokensV3 api.getNotWithdrawContractTokens.value

api.getNotWithdrawContractTokens.notes

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetNotWithdrawContractTokensV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetNotWithdrawContractTokensV3(ctx context.Context) ApiGetNotWithdrawContractTokensV3Request {
	return ApiGetNotWithdrawContractTokensV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return TokenInfoV3
func (a *LoopringDEXRestfulAPIApiService) GetNotWithdrawContractTokensV3Execute(r ApiGetNotWithdrawContractTokensV3Request) (*TokenInfoV3, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *TokenInfoV3
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetNotWithdrawContractTokensV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/exchange/notWithdrawContractTokens"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOrderAmountV2Request struct {
	ctx         context.Context
	ApiService  *LoopringDEXRestfulAPIApiService
	tokenSymbol *string
}

func (r ApiGetOrderAmountV2Request) TokenSymbol(tokenSymbol string) ApiGetOrderAmountV2Request {
	r.tokenSymbol = &tokenSymbol
	return r
}

func (r ApiGetOrderAmountV2Request) Execute() (*GetOrderAmountResponse, *http.Response, error) {
	return r.ApiService.GetOrderAmountV2Execute(r)
}

/*
GetOrderAmountV2 Query current token minimum amount to place order

Returns the minimum amount

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetOrderAmountV2Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetOrderAmountV2(ctx context.Context) ApiGetOrderAmountV2Request {
	return ApiGetOrderAmountV2Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GetOrderAmountResponse
func (a *LoopringDEXRestfulAPIApiService) GetOrderAmountV2Execute(r ApiGetOrderAmountV2Request) (*GetOrderAmountResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetOrderAmountResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetOrderAmountV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/user/orderAmount"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.tokenSymbol != nil {
		localVarQueryParams.Add("tokenSymbol", parameterToString(*r.tokenSymbol, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOrderAmountV3Request struct {
	ctx         context.Context
	ApiService  *LoopringDEXRestfulAPIApiService
	tokenSymbol *string
}

// Token symbol to place order
func (r ApiGetOrderAmountV3Request) TokenSymbol(tokenSymbol string) ApiGetOrderAmountV3Request {
	r.tokenSymbol = &tokenSymbol
	return r
}

func (r ApiGetOrderAmountV3Request) Execute() (*GetOrderAmountResponseData, *http.Response, error) {
	return r.ApiService.GetOrderAmountV3Execute(r)
}

/*
GetOrderAmountV3 Query current token minimum amount to place order

Returns the minimum amount

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetOrderAmountV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetOrderAmountV3(ctx context.Context) ApiGetOrderAmountV3Request {
	return ApiGetOrderAmountV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GetOrderAmountResponseData
func (a *LoopringDEXRestfulAPIApiService) GetOrderAmountV3Execute(r ApiGetOrderAmountV3Request) (*GetOrderAmountResponseData, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetOrderAmountResponseData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetOrderAmountV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/user/orderAmount"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tokenSymbol == nil {
		return localVarReturnValue, nil, reportError("tokenSymbol is required and must be specified")
	}

	localVarQueryParams.Add("tokenSymbol", parameterToString(*r.tokenSymbol, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOrderDetailV2Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	accountId  *int64
	orderHash  *string
}

// Account ID, could be empty if hash query is presented.
func (r ApiGetOrderDetailV2Request) AccountId(accountId int64) ApiGetOrderDetailV2Request {
	r.accountId = &accountId
	return r
}

// Order hash
func (r ApiGetOrderDetailV2Request) OrderHash(orderHash string) ApiGetOrderDetailV2Request {
	r.orderHash = &orderHash
	return r
}

func (r ApiGetOrderDetailV2Request) Execute() (*GetOrderDetailResponseV2, *http.Response, error) {
	return r.ApiService.GetOrderDetailV2Execute(r)
}

/*
GetOrderDetailV2 Get order details

Get the details of an order based on order hash.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetOrderDetailV2Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetOrderDetailV2(ctx context.Context) ApiGetOrderDetailV2Request {
	return ApiGetOrderDetailV2Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GetOrderDetailResponseV2
func (a *LoopringDEXRestfulAPIApiService) GetOrderDetailV2Execute(r ApiGetOrderDetailV2Request) (*GetOrderDetailResponseV2, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetOrderDetailResponseV2
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetOrderDetailV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.orderHash == nil {
		return localVarReturnValue, nil, reportError("orderHash is required and must be specified")
	}

	localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	localVarQueryParams.Add("orderHash", parameterToString(*r.orderHash, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOrderDetailV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	accountId  *int64
	orderHash  *string
}

// Account ID, could be empty if hash query is presented.
func (r ApiGetOrderDetailV3Request) AccountId(accountId int64) ApiGetOrderDetailV3Request {
	r.accountId = &accountId
	return r
}

// Order hash
func (r ApiGetOrderDetailV3Request) OrderHash(orderHash string) ApiGetOrderDetailV3Request {
	r.orderHash = &orderHash
	return r
}

func (r ApiGetOrderDetailV3Request) Execute() (*OrderDetailV3, *http.Response, error) {
	return r.ApiService.GetOrderDetailV3Execute(r)
}

/*
GetOrderDetailV3 Get order details

Get the details of an order based on order hash.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetOrderDetailV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetOrderDetailV3(ctx context.Context) ApiGetOrderDetailV3Request {
	return ApiGetOrderDetailV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return OrderDetailV3
func (a *LoopringDEXRestfulAPIApiService) GetOrderDetailV3Execute(r ApiGetOrderDetailV3Request) (*OrderDetailV3, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *OrderDetailV3
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetOrderDetailV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.orderHash == nil {
		return localVarReturnValue, nil, reportError("orderHash is required and must be specified")
	}

	localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	localVarQueryParams.Add("orderHash", parameterToString(*r.orderHash, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOrderUserRateAmountV2Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	accountId  *int64
	market     *string
}

func (r ApiGetOrderUserRateAmountV2Request) AccountId(accountId int64) ApiGetOrderUserRateAmountV2Request {
	r.accountId = &accountId
	return r
}

func (r ApiGetOrderUserRateAmountV2Request) Market(market string) ApiGetOrderUserRateAmountV2Request {
	r.market = &market
	return r
}

func (r ApiGetOrderUserRateAmountV2Request) Execute() (*GetOrderGroupAmountResponse, *http.Response, error) {
	return r.ApiService.GetOrderUserRateAmountV2Execute(r)
}

/*
GetOrderUserRateAmountV2 Query current token minimum amount to place order

Returns the minimum amount

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetOrderUserRateAmountV2Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetOrderUserRateAmountV2(ctx context.Context) ApiGetOrderUserRateAmountV2Request {
	return ApiGetOrderUserRateAmountV2Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GetOrderGroupAmountResponse
func (a *LoopringDEXRestfulAPIApiService) GetOrderUserRateAmountV2Execute(r ApiGetOrderUserRateAmountV2Request) (*GetOrderGroupAmountResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetOrderGroupAmountResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetOrderUserRateAmountV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/user/orderUserRateAmount"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.accountId != nil {
		localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	}
	if r.market != nil {
		localVarQueryParams.Add("market", parameterToString(*r.market, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOrderUserRateAmountV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	accountId  *int64
	market     *string
}

// Account ID, some hash query APIs doesnt need it if in hash query mode, check require flag of each API to see if its a must.
func (r ApiGetOrderUserRateAmountV3Request) AccountId(accountId int64) ApiGetOrderUserRateAmountV3Request {
	r.accountId = &accountId
	return r
}

// Trading pair
func (r ApiGetOrderUserRateAmountV3Request) Market(market string) ApiGetOrderUserRateAmountV3Request {
	r.market = &market
	return r
}

func (r ApiGetOrderUserRateAmountV3Request) Execute() (*GetOrderGroupAmountData, *http.Response, error) {
	return r.ApiService.GetOrderUserRateAmountV3Execute(r)
}

/*
GetOrderUserRateAmountV3 Query current token minimum amount to place order based on users VIP level and max fee bips

This API returns 2 minimum amounts, one is based on users fee rate, the other is based on the maximum fee bips which is 0.6%. In other words, if user wants to keep fee rate, the minimum order is higher, otherwise he needs to pay more but can place less amount orders.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetOrderUserRateAmountV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetOrderUserRateAmountV3(ctx context.Context) ApiGetOrderUserRateAmountV3Request {
	return ApiGetOrderUserRateAmountV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GetOrderGroupAmountData
func (a *LoopringDEXRestfulAPIApiService) GetOrderUserRateAmountV3Execute(r ApiGetOrderUserRateAmountV3Request) (*GetOrderGroupAmountData, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetOrderGroupAmountData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetOrderUserRateAmountV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/user/orderUserRateAmount"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.market == nil {
		return localVarReturnValue, nil, reportError("market is required and must be specified")
	}

	localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	localVarQueryParams.Add("market", parameterToString(*r.market, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOrdersV2Request struct {
	ctx           context.Context
	ApiService    *LoopringDEXRestfulAPIApiService
	accountId     *int32
	market        *string
	start         *int64
	end           *int64
	side          *string
	status        *string
	limit         *int32
	offset        *int64
	orderTypes    *string
	tradeChannels *string
}

// Account ID
func (r ApiGetOrdersV2Request) AccountId(accountId int32) ApiGetOrdersV2Request {
	r.accountId = &accountId
	return r
}

// Trading pair
func (r ApiGetOrdersV2Request) Market(market string) ApiGetOrdersV2Request {
	r.market = &market
	return r
}

// Lower bound of order&#39;s creation timestamp in millisecond
func (r ApiGetOrdersV2Request) Start(start int64) ApiGetOrdersV2Request {
	r.start = &start
	return r
}

// Upper bound of order&#39;s creation timestamp in millisecond
func (r ApiGetOrdersV2Request) End(end int64) ApiGetOrdersV2Request {
	r.end = &end
	return r
}

// \&quot;BUY\&quot; or \&quot;SELL\&quot;
func (r ApiGetOrdersV2Request) Side(side string) ApiGetOrdersV2Request {
	r.side = &side
	return r
}

// Order status. You can specify one of the following values:
func (r ApiGetOrdersV2Request) Status(status string) ApiGetOrdersV2Request {
	r.status = &status
	return r
}

// Limit of orders (default 50)
func (r ApiGetOrdersV2Request) Limit(limit int32) ApiGetOrdersV2Request {
	r.limit = &limit
	return r
}

// Offset of orders (default 0)
func (r ApiGetOrdersV2Request) Offset(offset int64) ApiGetOrdersV2Request {
	r.offset = &offset
	return r
}

// request.getOrders.orderTypes
func (r ApiGetOrdersV2Request) OrderTypes(orderTypes string) ApiGetOrdersV2Request {
	r.orderTypes = &orderTypes
	return r
}

// field.SubmitOrderRequest.tradeChannel
func (r ApiGetOrdersV2Request) TradeChannels(tradeChannels string) ApiGetOrdersV2Request {
	r.tradeChannels = &tradeChannels
	return r
}

func (r ApiGetOrdersV2Request) Execute() (*GetOrdersResponseV2, *http.Response, error) {
	return r.ApiService.GetOrdersV2Execute(r)
}

/*
GetOrdersV2 Get multiple orders

Get a list of orders satisfying certain criteria.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetOrdersV2Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetOrdersV2(ctx context.Context) ApiGetOrdersV2Request {
	return ApiGetOrdersV2Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GetOrdersResponseV2
func (a *LoopringDEXRestfulAPIApiService) GetOrdersV2Execute(r ApiGetOrdersV2Request) (*GetOrdersResponseV2, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetOrdersResponseV2
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetOrdersV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/orders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}

	localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	if r.market != nil {
		localVarQueryParams.Add("market", parameterToString(*r.market, ""))
	}
	if r.start != nil {
		localVarQueryParams.Add("start", parameterToString(*r.start, ""))
	}
	if r.end != nil {
		localVarQueryParams.Add("end", parameterToString(*r.end, ""))
	}
	if r.side != nil {
		localVarQueryParams.Add("side", parameterToString(*r.side, ""))
	}
	if r.status != nil {
		localVarQueryParams.Add("status", parameterToString(*r.status, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.orderTypes != nil {
		localVarQueryParams.Add("orderTypes", parameterToString(*r.orderTypes, ""))
	}
	if r.tradeChannels != nil {
		localVarQueryParams.Add("tradeChannels", parameterToString(*r.tradeChannels, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOrdersV3Request struct {
	ctx           context.Context
	ApiService    *LoopringDEXRestfulAPIApiService
	accountId     *int32
	market        *string
	start         *int64
	end           *int64
	side          *string
	status        *string
	limit         *int32
	offset        *int64
	orderTypes    *string
	tradeChannels *string
}

// Account ID
func (r ApiGetOrdersV3Request) AccountId(accountId int32) ApiGetOrdersV3Request {
	r.accountId = &accountId
	return r
}

// Trading pair
func (r ApiGetOrdersV3Request) Market(market string) ApiGetOrdersV3Request {
	r.market = &market
	return r
}

// Lower bound of order&#39;s creation timestamp in millisecond
func (r ApiGetOrdersV3Request) Start(start int64) ApiGetOrdersV3Request {
	r.start = &start
	return r
}

// Upper bound of order&#39;s creation timestamp in millisecond
func (r ApiGetOrdersV3Request) End(end int64) ApiGetOrdersV3Request {
	r.end = &end
	return r
}

// \&quot;BUY\&quot; or \&quot;SELL\&quot;
func (r ApiGetOrdersV3Request) Side(side string) ApiGetOrdersV3Request {
	r.side = &side
	return r
}

// Order status. You can specify one of the following values:
func (r ApiGetOrdersV3Request) Status(status string) ApiGetOrdersV3Request {
	r.status = &status
	return r
}

// Limit of orders (default 50)
func (r ApiGetOrdersV3Request) Limit(limit int32) ApiGetOrdersV3Request {
	r.limit = &limit
	return r
}

// Offset of orders (default 0)
func (r ApiGetOrdersV3Request) Offset(offset int64) ApiGetOrdersV3Request {
	r.offset = &offset
	return r
}

// request.getOrders.orderTypes
func (r ApiGetOrdersV3Request) OrderTypes(orderTypes string) ApiGetOrdersV3Request {
	r.orderTypes = &orderTypes
	return r
}

// field.SubmitOrderRequest.tradeChannel
func (r ApiGetOrdersV3Request) TradeChannels(tradeChannels string) ApiGetOrdersV3Request {
	r.tradeChannels = &tradeChannels
	return r
}

func (r ApiGetOrdersV3Request) Execute() (*OrdersDetailV3, *http.Response, error) {
	return r.ApiService.GetOrdersV3Execute(r)
}

/*
GetOrdersV3 Get multiple orders

Get a list of orders satisfying certain criteria.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetOrdersV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetOrdersV3(ctx context.Context) ApiGetOrdersV3Request {
	return ApiGetOrdersV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return OrdersDetailV3
func (a *LoopringDEXRestfulAPIApiService) GetOrdersV3Execute(r ApiGetOrdersV3Request) (*OrdersDetailV3, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *OrdersDetailV3
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetOrdersV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/orders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}

	localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	if r.market != nil {
		localVarQueryParams.Add("market", parameterToString(*r.market, ""))
	}
	if r.start != nil {
		localVarQueryParams.Add("start", parameterToString(*r.start, ""))
	}
	if r.end != nil {
		localVarQueryParams.Add("end", parameterToString(*r.end, ""))
	}
	if r.side != nil {
		localVarQueryParams.Add("side", parameterToString(*r.side, ""))
	}
	if r.status != nil {
		localVarQueryParams.Add("status", parameterToString(*r.status, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.orderTypes != nil {
		localVarQueryParams.Add("orderTypes", parameterToString(*r.orderTypes, ""))
	}
	if r.tradeChannels != nil {
		localVarQueryParams.Add("tradeChannels", parameterToString(*r.tradeChannels, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPendingRequestsV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
}

func (r ApiGetPendingRequestsV3Request) Execute() (*TransactionBlock, *http.Response, error) {
	return r.ApiService.GetPendingRequestsV3Execute(r)
}

/*
GetPendingRequestsV3 Get pending txs

Get pending txs to be packed into next block

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetPendingRequestsV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetPendingRequestsV3(ctx context.Context) ApiGetPendingRequestsV3Request {
	return ApiGetPendingRequestsV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return TransactionBlock
func (a *LoopringDEXRestfulAPIApiService) GetPendingRequestsV3Execute(r ApiGetPendingRequestsV3Request) (*TransactionBlock, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *TransactionBlock
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetPendingRequestsV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/block/getPendingRequests"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPoolsStatsAmmV3Request struct {
	ctx            context.Context
	ApiService     *LoopringDEXRestfulAPIApiService
	ammPoolMarkets *string
}

func (r ApiGetPoolsStatsAmmV3Request) AmmPoolMarkets(ammPoolMarkets string) ApiGetPoolsStatsAmmV3Request {
	r.ammPoolMarkets = &ammPoolMarkets
	return r
}

func (r ApiGetPoolsStatsAmmV3Request) Execute() (*GetAmmPoolsStatsResponse, *http.Response, error) {
	return r.ApiService.GetPoolsStatsAmmV3Execute(r)
}

/*
GetPoolsStatsAmmV3 api.getPoolsStats.value

api.getPoolsStats.notes

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetPoolsStatsAmmV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetPoolsStatsAmmV3(ctx context.Context) ApiGetPoolsStatsAmmV3Request {
	return ApiGetPoolsStatsAmmV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GetAmmPoolsStatsResponse
func (a *LoopringDEXRestfulAPIApiService) GetPoolsStatsAmmV3Execute(r ApiGetPoolsStatsAmmV3Request) (*GetAmmPoolsStatsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetAmmPoolsStatsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetPoolsStatsAmmV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/amm/poolsStats"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ammPoolMarkets != nil {
		localVarQueryParams.Add("ammPoolMarkets", parameterToString(*r.ammPoolMarkets, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPoolsStatsV2Request struct {
	ctx            context.Context
	ApiService     *LoopringDEXRestfulAPIApiService
	ammPoolMarkets *string
}

func (r ApiGetPoolsStatsV2Request) AmmPoolMarkets(ammPoolMarkets string) ApiGetPoolsStatsV2Request {
	r.ammPoolMarkets = &ammPoolMarkets
	return r
}

func (r ApiGetPoolsStatsV2Request) Execute() (*GetAmmPoolsStatsResponse, *http.Response, error) {
	return r.ApiService.GetPoolsStatsV2Execute(r)
}

/*
GetPoolsStatsV2 api.getPoolsStats.value

api.getPoolsStats.notes

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetPoolsStatsV2Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetPoolsStatsV2(ctx context.Context) ApiGetPoolsStatsV2Request {
	return ApiGetPoolsStatsV2Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GetAmmPoolsStatsResponse
func (a *LoopringDEXRestfulAPIApiService) GetPoolsStatsV2Execute(r ApiGetPoolsStatsV2Request) (*GetAmmPoolsStatsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetAmmPoolsStatsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetPoolsStatsV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/amm/poolsStats"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ammPoolMarkets != nil {
		localVarQueryParams.Add("ammPoolMarkets", parameterToString(*r.ammPoolMarkets, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPoolsStatsV3Request struct {
	ctx            context.Context
	ApiService     *LoopringDEXRestfulAPIApiService
	ammPoolMarkets *string
}

func (r ApiGetPoolsStatsV3Request) AmmPoolMarkets(ammPoolMarkets string) ApiGetPoolsStatsV3Request {
	r.ammPoolMarkets = &ammPoolMarkets
	return r
}

func (r ApiGetPoolsStatsV3Request) Execute() (*AmmPoolStatistics, *http.Response, error) {
	return r.ApiService.GetPoolsStatsV3Execute(r)
}

/*
GetPoolsStatsV3 api.getPoolsStats.value

api.getPoolsStats.notes

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetPoolsStatsV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetPoolsStatsV3(ctx context.Context) ApiGetPoolsStatsV3Request {
	return ApiGetPoolsStatsV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return AmmPoolStatistics
func (a *LoopringDEXRestfulAPIApiService) GetPoolsStatsV3Execute(r ApiGetPoolsStatsV3Request) (*AmmPoolStatistics, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AmmPoolStatistics
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetPoolsStatsV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/poolsStats"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ammPoolMarkets != nil {
		localVarQueryParams.Add("ammPoolMarkets", parameterToString(*r.ammPoolMarkets, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPriceV2Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	legal      *string
}

// request.getPrice.legal
func (r ApiGetPriceV2Request) Legal(legal string) ApiGetPriceV2Request {
	r.legal = &legal
	return r
}

func (r ApiGetPriceV2Request) Execute() (*GetPriceV2Response, *http.Response, error) {
	return r.ApiService.GetPriceV2Execute(r)
}

/*
GetPriceV2 Get token fiat prices

Fetches, for all the tokens supported by Loopring, their fiat price.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetPriceV2Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetPriceV2(ctx context.Context) ApiGetPriceV2Request {
	return ApiGetPriceV2Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GetPriceV2Response
func (a *LoopringDEXRestfulAPIApiService) GetPriceV2Execute(r ApiGetPriceV2Request) (*GetPriceV2Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetPriceV2Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetPriceV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/price"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.legal == nil {
		return localVarReturnValue, nil, reportError("legal is required and must be specified")
	}

	localVarQueryParams.Add("legal", parameterToString(*r.legal, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPriceV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	legal      *string
}

// The fiat currency to uses. Currently the following values are supported: USD,CNY,JPY,EUR,GBP,HKD
func (r ApiGetPriceV3Request) Legal(legal string) ApiGetPriceV3Request {
	r.legal = &legal
	return r
}

func (r ApiGetPriceV3Request) Execute() (*GetPriceResponseV3, *http.Response, error) {
	return r.ApiService.GetPriceV3Execute(r)
}

/*
GetPriceV3 Get token fiat prices

Fetches, for all the tokens supported by Loopring, their fiat price.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetPriceV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetPriceV3(ctx context.Context) ApiGetPriceV3Request {
	return ApiGetPriceV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GetPriceResponseV3
func (a *LoopringDEXRestfulAPIApiService) GetPriceV3Execute(r ApiGetPriceV3Request) (*GetPriceResponseV3, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetPriceResponseV3
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetPriceV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/price"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.legal == nil {
		return localVarReturnValue, nil, reportError("legal is required and must be specified")
	}

	localVarQueryParams.Add("legal", parameterToString(*r.legal, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProfitSharingStatusV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	accountId  *int64
	tokenId    *int32
	start      *int64
	size       *int32
	rewardType *int32
	taker      *int32
}

func (r ApiGetProfitSharingStatusV3Request) AccountId(accountId int64) ApiGetProfitSharingStatusV3Request {
	r.accountId = &accountId
	return r
}

func (r ApiGetProfitSharingStatusV3Request) TokenId(tokenId int32) ApiGetProfitSharingStatusV3Request {
	r.tokenId = &tokenId
	return r
}

func (r ApiGetProfitSharingStatusV3Request) Start(start int64) ApiGetProfitSharingStatusV3Request {
	r.start = &start
	return r
}

func (r ApiGetProfitSharingStatusV3Request) Size(size int32) ApiGetProfitSharingStatusV3Request {
	r.size = &size
	return r
}

func (r ApiGetProfitSharingStatusV3Request) RewardType(rewardType int32) ApiGetProfitSharingStatusV3Request {
	r.rewardType = &rewardType
	return r
}

func (r ApiGetProfitSharingStatusV3Request) Taker(taker int32) ApiGetProfitSharingStatusV3Request {
	r.taker = &taker
	return r
}

func (r ApiGetProfitSharingStatusV3Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetProfitSharingStatusV3Execute(r)
}

/*
GetProfitSharingStatusV3 Method for GetProfitSharingStatusV3

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetProfitSharingStatusV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetProfitSharingStatusV3(ctx context.Context) ApiGetProfitSharingStatusV3Request {
	return ApiGetProfitSharingStatusV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *LoopringDEXRestfulAPIApiService) GetProfitSharingStatusV3Execute(r ApiGetProfitSharingStatusV3Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetProfitSharingStatusV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/sidecar/profitShareReward"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.accountId != nil {
		localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	}
	if r.tokenId != nil {
		localVarQueryParams.Add("tokenId", parameterToString(*r.tokenId, ""))
	}
	if r.start != nil {
		localVarQueryParams.Add("start", parameterToString(*r.start, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.rewardType != nil {
		localVarQueryParams.Add("rewardType", parameterToString(*r.rewardType, ""))
	}
	if r.taker != nil {
		localVarQueryParams.Add("taker", parameterToString(*r.taker, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProtocolPortraitV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	timestamp  *int64
}

func (r ApiGetProtocolPortraitV3Request) Timestamp(timestamp int64) ApiGetProtocolPortraitV3Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetProtocolPortraitV3Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetProtocolPortraitV3Execute(r)
}

/*
GetProtocolPortraitV3 Method for GetProtocolPortraitV3

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetProtocolPortraitV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetProtocolPortraitV3(ctx context.Context) ApiGetProtocolPortraitV3Request {
	return ApiGetProtocolPortraitV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *LoopringDEXRestfulAPIApiService) GetProtocolPortraitV3Execute(r ApiGetProtocolPortraitV3Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetProtocolPortraitV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/sidecar/ProtocolPortrait"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.timestamp != nil {
		localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRecommendedGasPriceRangeV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
}

func (r ApiGetRecommendedGasPriceRangeV3Request) Execute() (*GetRecommendedGasPriceResponseRangeV2, *http.Response, error) {
	return r.ApiService.GetRecommendedGasPriceRangeV3Execute(r)
}

/*
GetRecommendedGasPriceRangeV3 Get recommended gas price

Get recommended gas price in Gwei.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetRecommendedGasPriceRangeV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetRecommendedGasPriceRangeV3(ctx context.Context) ApiGetRecommendedGasPriceRangeV3Request {
	return ApiGetRecommendedGasPriceRangeV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GetRecommendedGasPriceResponseRangeV2
func (a *LoopringDEXRestfulAPIApiService) GetRecommendedGasPriceRangeV3Execute(r ApiGetRecommendedGasPriceRangeV3Request) (*GetRecommendedGasPriceResponseRangeV2, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetRecommendedGasPriceResponseRangeV2
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetRecommendedGasPriceRangeV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/eth/recommendedGasPriceRange"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRecommendedGasPriceV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
}

func (r ApiGetRecommendedGasPriceV3Request) Execute() (*GetRecommendedGasPriceResponseV2, *http.Response, error) {
	return r.ApiService.GetRecommendedGasPriceV3Execute(r)
}

/*
GetRecommendedGasPriceV3 Get recommended gas price

Get recommended gas price in Gwei.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetRecommendedGasPriceV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetRecommendedGasPriceV3(ctx context.Context) ApiGetRecommendedGasPriceV3Request {
	return ApiGetRecommendedGasPriceV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GetRecommendedGasPriceResponseV2
func (a *LoopringDEXRestfulAPIApiService) GetRecommendedGasPriceV3Execute(r ApiGetRecommendedGasPriceV3Request) (*GetRecommendedGasPriceResponseV2, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetRecommendedGasPriceResponseV2
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetRecommendedGasPriceV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/eth/recommendedGasPrice"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRecommendedMarketsV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	size       *int32
}

func (r ApiGetRecommendedMarketsV3Request) Size(size int32) ApiGetRecommendedMarketsV3Request {
	r.size = &size
	return r
}

func (r ApiGetRecommendedMarketsV3Request) Execute() (*GetExchangeFeeInfoResponseData, *http.Response, error) {
	return r.ApiService.GetRecommendedMarketsV3Execute(r)
}

/*
GetRecommendedMarketsV3 api.getRecommendedMarkets.value

api.getRecommendedMarkets.notes

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetRecommendedMarketsV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetRecommendedMarketsV3(ctx context.Context) ApiGetRecommendedMarketsV3Request {
	return ApiGetRecommendedMarketsV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GetExchangeFeeInfoResponseData
func (a *LoopringDEXRestfulAPIApiService) GetRecommendedMarketsV3Execute(r ApiGetRecommendedMarketsV3Request) (*GetExchangeFeeInfoResponseData, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetExchangeFeeInfoResponseData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetRecommendedMarketsV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/exchange/recommended"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRequestInBlockV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	hashes     *string
}

// L2 tx hash
func (r ApiGetRequestInBlockV3Request) Hashes(hashes string) ApiGetRequestInBlockV3Request {
	r.hashes = &hashes
	return r
}

func (r ApiGetRequestInBlockV3Request) Execute() (*RequestInBlockResponse, *http.Response, error) {
	return r.ApiService.GetRequestInBlockV3Execute(r)
}

/*
GetRequestInBlockV3 Get a txs block

Get block to which a L2 tx belongs

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetRequestInBlockV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetRequestInBlockV3(ctx context.Context) ApiGetRequestInBlockV3Request {
	return ApiGetRequestInBlockV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return RequestInBlockResponse
func (a *LoopringDEXRestfulAPIApiService) GetRequestInBlockV3Execute(r ApiGetRequestInBlockV3Request) (*RequestInBlockResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *RequestInBlockResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetRequestInBlockV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/requestInBlock"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.hashes != nil {
		localVarQueryParams.Add("hashes", parameterToString(*r.hashes, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTickerV2Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	market     *string
}

// Market pair, support multiple markets
func (r ApiGetTickerV2Request) Market(market string) ApiGetTickerV2Request {
	r.market = &market
	return r
}

func (r ApiGetTickerV2Request) Execute() (*GetTickerResponseV2, *http.Response, error) {
	return r.ApiService.GetTickerV2Execute(r)
}

/*
GetTickerV2 Get market ticker

Gets a markets ticker. Generally speaking, a ticker in Loopring consists in data from the market taken last 24Hours.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTickerV2Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetTickerV2(ctx context.Context) ApiGetTickerV2Request {
	return ApiGetTickerV2Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GetTickerResponseV2
func (a *LoopringDEXRestfulAPIApiService) GetTickerV2Execute(r ApiGetTickerV2Request) (*GetTickerResponseV2, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetTickerResponseV2
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetTickerV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/ticker"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.market == nil {
		return localVarReturnValue, nil, reportError("market is required and must be specified")
	}

	localVarQueryParams.Add("market", parameterToString(*r.market, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTickerV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	market     *string
}

// Market pair, support multiple markets
func (r ApiGetTickerV3Request) Market(market string) ApiGetTickerV3Request {
	r.market = &market
	return r
}

func (r ApiGetTickerV3Request) Execute() (*GetTickerResponseV3, *http.Response, error) {
	return r.ApiService.GetTickerV3Execute(r)
}

/*
GetTickerV3 Get market ticker

Gets a markets ticker. Generally speaking, a ticker in Loopring consists in data from the market taken last 24Hours.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTickerV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetTickerV3(ctx context.Context) ApiGetTickerV3Request {
	return ApiGetTickerV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GetTickerResponseV3
func (a *LoopringDEXRestfulAPIApiService) GetTickerV3Execute(r ApiGetTickerV3Request) (*GetTickerResponseV3, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetTickerResponseV3
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetTickerV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/ticker"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.market == nil {
		return localVarReturnValue, nil, reportError("market is required and must be specified")
	}

	localVarQueryParams.Add("market", parameterToString(*r.market, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimestampV2Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
}

func (r ApiGetTimestampV2Request) Execute() (*GetTimestampV2Response, *http.Response, error) {
	return r.ApiService.GetTimestampV2Execute(r)
}

/*
GetTimestampV2 Get relayer's current time

Returns the relayer's current time in millisecond

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimestampV2Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetTimestampV2(ctx context.Context) ApiGetTimestampV2Request {
	return ApiGetTimestampV2Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GetTimestampV2Response
func (a *LoopringDEXRestfulAPIApiService) GetTimestampV2Execute(r ApiGetTimestampV2Request) (*GetTimestampV2Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetTimestampV2Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetTimestampV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/timestamp"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimestampV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
}

func (r ApiGetTimestampV3Request) Execute() (*TimestampV3, *http.Response, error) {
	return r.ApiService.GetTimestampV3Execute(r)
}

/*
GetTimestampV3 Get relayer's current time

Returns the relayer's current time in millisecond

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimestampV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetTimestampV3(ctx context.Context) ApiGetTimestampV3Request {
	return ApiGetTimestampV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return TimestampV3
func (a *LoopringDEXRestfulAPIApiService) GetTimestampV3Execute(r ApiGetTimestampV3Request) (*TimestampV3, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *TimestampV3
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetTimestampV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/timestamp"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTokenBalanceV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	owner      *string
	token      *string
}

// Ethereum address
func (r ApiGetTokenBalanceV3Request) Owner(owner string) ApiGetTokenBalanceV3Request {
	r.owner = &owner
	return r
}

// Token&#39;s ERC20 address
func (r ApiGetTokenBalanceV3Request) Token(token string) ApiGetTokenBalanceV3Request {
	r.token = &token
	return r
}

func (r ApiGetTokenBalanceV3Request) Execute() (*GetTokenBalancesV2Response, *http.Response, error) {
	return r.ApiService.GetTokenBalanceV3Execute(r)
}

/*
GetTokenBalanceV3 Get user token balance

Returns user's token balance on Ethereum mainnet (not token's balance on Loopring.io)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTokenBalanceV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetTokenBalanceV3(ctx context.Context) ApiGetTokenBalanceV3Request {
	return ApiGetTokenBalanceV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GetTokenBalancesV2Response
func (a *LoopringDEXRestfulAPIApiService) GetTokenBalanceV3Execute(r ApiGetTokenBalanceV3Request) (*GetTokenBalancesV2Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetTokenBalancesV2Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetTokenBalanceV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/eth/tokenBalances"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.owner == nil {
		return localVarReturnValue, nil, reportError("owner is required and must be specified")
	}
	if r.token == nil {
		return localVarReturnValue, nil, reportError("token is required and must be specified")
	}

	localVarQueryParams.Add("owner", parameterToString(*r.owner, ""))
	localVarQueryParams.Add("token", parameterToString(*r.token, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTokenDecimalV2Request struct {
	ctx            context.Context
	ApiService     *LoopringDEXRestfulAPIApiService
	tokenAddresses *string
	network        *string
}

// token address to be queried
func (r ApiGetTokenDecimalV2Request) TokenAddresses(tokenAddresses string) ApiGetTokenDecimalV2Request {
	r.tokenAddresses = &tokenAddresses
	return r
}

// network
func (r ApiGetTokenDecimalV2Request) Network(network string) ApiGetTokenDecimalV2Request {
	r.network = &network
	return r
}

func (r ApiGetTokenDecimalV2Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetTokenDecimalV2Execute(r)
}

/*
GetTokenDecimalV2 Method for GetTokenDecimalV2

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTokenDecimalV2Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetTokenDecimalV2(ctx context.Context) ApiGetTokenDecimalV2Request {
	return ApiGetTokenDecimalV2Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *LoopringDEXRestfulAPIApiService) GetTokenDecimalV2Execute(r ApiGetTokenDecimalV2Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetTokenDecimalV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/token/decimal"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tokenAddresses == nil {
		return localVarReturnValue, nil, reportError("tokenAddresses is required and must be specified")
	}
	if r.network == nil {
		return localVarReturnValue, nil, reportError("network is required and must be specified")
	}

	localVarQueryParams.Add("tokenAddresses", parameterToString(*r.tokenAddresses, ""))
	localVarQueryParams.Add("network", parameterToString(*r.network, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTokenInfoV3Request struct {
	ctx          context.Context
	ApiService   *LoopringDEXRestfulAPIApiService
	tokenAddress *string
}

// token address to be queried
func (r ApiGetTokenInfoV3Request) TokenAddress(tokenAddress string) ApiGetTokenInfoV3Request {
	r.tokenAddress = &tokenAddress
	return r
}

func (r ApiGetTokenInfoV3Request) Execute() (*GetUserBalancesResponseV2, *http.Response, error) {
	return r.ApiService.GetTokenInfoV3Execute(r)
}

/*
GetTokenInfoV3 api.getTokenInfo.value

api.getTokenInfo.notes

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTokenInfoV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetTokenInfoV3(ctx context.Context) ApiGetTokenInfoV3Request {
	return ApiGetTokenInfoV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GetUserBalancesResponseV2
func (a *LoopringDEXRestfulAPIApiService) GetTokenInfoV3Execute(r ApiGetTokenInfoV3Request) (*GetUserBalancesResponseV2, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetUserBalancesResponseV2
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetTokenInfoV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/spi/tokenInfo"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.tokenAddress != nil {
		localVarQueryParams.Add("tokenAddress", parameterToString(*r.tokenAddress, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTokenPricesV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	token      *string
	limit      *int32
	interval   *string
	currency   *string
}

func (r ApiGetTokenPricesV3Request) Token(token string) ApiGetTokenPricesV3Request {
	r.token = &token
	return r
}

func (r ApiGetTokenPricesV3Request) Limit(limit int32) ApiGetTokenPricesV3Request {
	r.limit = &limit
	return r
}

func (r ApiGetTokenPricesV3Request) Interval(interval string) ApiGetTokenPricesV3Request {
	r.interval = &interval
	return r
}

func (r ApiGetTokenPricesV3Request) Currency(currency string) ApiGetTokenPricesV3Request {
	r.currency = &currency
	return r
}

func (r ApiGetTokenPricesV3Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetTokenPricesV3Execute(r)
}

/*
GetTokenPricesV3 Method for GetTokenPricesV3

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTokenPricesV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetTokenPricesV3(ctx context.Context) ApiGetTokenPricesV3Request {
	return ApiGetTokenPricesV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *LoopringDEXRestfulAPIApiService) GetTokenPricesV3Execute(r ApiGetTokenPricesV3Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetTokenPricesV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/datacenter/getTokenPrices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.token != nil {
		localVarQueryParams.Add("token", parameterToString(*r.token, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.interval != nil {
		localVarQueryParams.Add("interval", parameterToString(*r.interval, ""))
	}
	if r.currency != nil {
		localVarQueryParams.Add("currency", parameterToString(*r.currency, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTokensV2Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
}

func (r ApiGetTokensV2Request) Execute() (*GetTokenInfoResponse, *http.Response, error) {
	return r.ApiService.GetTokensV2Execute(r)
}

/*
GetTokensV2 Get token configurations

Returns the configurations of all supported tokens, including Ether.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTokensV2Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetTokensV2(ctx context.Context) ApiGetTokensV2Request {
	return ApiGetTokensV2Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GetTokenInfoResponse
func (a *LoopringDEXRestfulAPIApiService) GetTokensV2Execute(r ApiGetTokensV2Request) (*GetTokenInfoResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetTokenInfoResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetTokensV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/exchange/tokens"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTokensV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
}

func (r ApiGetTokensV3Request) Execute() (*TokenInfoV3, *http.Response, error) {
	return r.ApiService.GetTokensV3Execute(r)
}

/*
GetTokensV3 Get token configurations

Returns the configurations of all supported tokens, including Ether.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTokensV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetTokensV3(ctx context.Context) ApiGetTokensV3Request {
	return ApiGetTokensV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return TokenInfoV3
func (a *LoopringDEXRestfulAPIApiService) GetTokensV3Execute(r ApiGetTokensV3Request) (*TokenInfoV3, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *TokenInfoV3
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetTokensV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/exchange/tokens"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTournamentRankV3Request struct {
	ctx           context.Context
	ApiService    *LoopringDEXRestfulAPIApiService
	ammPoolMarket *string
}

func (r ApiGetTournamentRankV3Request) AmmPoolMarket(ammPoolMarket string) ApiGetTournamentRankV3Request {
	r.ammPoolMarket = &ammPoolMarket
	return r
}

func (r ApiGetTournamentRankV3Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetTournamentRankV3Execute(r)
}

/*
GetTournamentRankV3 Method for GetTournamentRankV3

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTournamentRankV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetTournamentRankV3(ctx context.Context) ApiGetTournamentRankV3Request {
	return ApiGetTournamentRankV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *LoopringDEXRestfulAPIApiService) GetTournamentRankV3Execute(r ApiGetTournamentRankV3Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetTournamentRankV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/game/rank"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ammPoolMarket != nil {
		localVarQueryParams.Add("ammPoolMarket", parameterToString(*r.ammPoolMarket, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserAssetsV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	address    *string
	currency   *string
	assetTypes *string
	token      *string
	limit      *int32
}

func (r ApiGetUserAssetsV3Request) Address(address string) ApiGetUserAssetsV3Request {
	r.address = &address
	return r
}

func (r ApiGetUserAssetsV3Request) Currency(currency string) ApiGetUserAssetsV3Request {
	r.currency = &currency
	return r
}

func (r ApiGetUserAssetsV3Request) AssetTypes(assetTypes string) ApiGetUserAssetsV3Request {
	r.assetTypes = &assetTypes
	return r
}

func (r ApiGetUserAssetsV3Request) Token(token string) ApiGetUserAssetsV3Request {
	r.token = &token
	return r
}

func (r ApiGetUserAssetsV3Request) Limit(limit int32) ApiGetUserAssetsV3Request {
	r.limit = &limit
	return r
}

func (r ApiGetUserAssetsV3Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetUserAssetsV3Execute(r)
}

/*
GetUserAssetsV3 Method for GetUserAssetsV3

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUserAssetsV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetUserAssetsV3(ctx context.Context) ApiGetUserAssetsV3Request {
	return ApiGetUserAssetsV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *LoopringDEXRestfulAPIApiService) GetUserAssetsV3Execute(r ApiGetUserAssetsV3Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetUserAssetsV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/datacenter/getUserAssets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.address != nil {
		localVarQueryParams.Add("address", parameterToString(*r.address, ""))
	}
	if r.currency != nil {
		localVarQueryParams.Add("currency", parameterToString(*r.currency, ""))
	}
	if r.assetTypes != nil {
		localVarQueryParams.Add("assetTypes", parameterToString(*r.assetTypes, ""))
	}
	if r.token != nil {
		localVarQueryParams.Add("token", parameterToString(*r.token, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserBalancesV2Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	accountId  *int32
	tokens     *string
}

// AccountID
func (r ApiGetUserBalancesV2Request) AccountId(accountId int32) ApiGetUserBalancesV2Request {
	r.accountId = &accountId
	return r
}

// Query tokens
func (r ApiGetUserBalancesV2Request) Tokens(tokens string) ApiGetUserBalancesV2Request {
	r.tokens = &tokens
	return r
}

func (r ApiGetUserBalancesV2Request) Execute() (*GetUserBalancesResponseV2, *http.Response, error) {
	return r.ApiService.GetUserBalancesV2Execute(r)
}

/*
GetUserBalancesV2 Get user exchange balances

Returns user's Ether and token balances on exchange.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUserBalancesV2Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetUserBalancesV2(ctx context.Context) ApiGetUserBalancesV2Request {
	return ApiGetUserBalancesV2Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GetUserBalancesResponseV2
func (a *LoopringDEXRestfulAPIApiService) GetUserBalancesV2Execute(r ApiGetUserBalancesV2Request) (*GetUserBalancesResponseV2, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetUserBalancesResponseV2
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetUserBalancesV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/user/balances"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}

	localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	if r.tokens != nil {
		localVarQueryParams.Add("tokens", parameterToString(*r.tokens, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserBalancesV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	accountId  *int32
	tokens     *string
}

// AccountID
func (r ApiGetUserBalancesV3Request) AccountId(accountId int32) ApiGetUserBalancesV3Request {
	r.accountId = &accountId
	return r
}

// Query tokens
func (r ApiGetUserBalancesV3Request) Tokens(tokens string) ApiGetUserBalancesV3Request {
	r.tokens = &tokens
	return r
}

func (r ApiGetUserBalancesV3Request) Execute() (*BalanceV3, *http.Response, error) {
	return r.ApiService.GetUserBalancesV3Execute(r)
}

/*
GetUserBalancesV3 Get user exchange balances

Returns user's Ether and token balances on exchange.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUserBalancesV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetUserBalancesV3(ctx context.Context) ApiGetUserBalancesV3Request {
	return ApiGetUserBalancesV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return BalanceV3
func (a *LoopringDEXRestfulAPIApiService) GetUserBalancesV3Execute(r ApiGetUserBalancesV3Request) (*BalanceV3, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BalanceV3
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetUserBalancesV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/user/balances"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}

	localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	if r.tokens != nil {
		localVarQueryParams.Add("tokens", parameterToString(*r.tokens, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserBillV3Request struct {
	ctx             context.Context
	ApiService      *LoopringDEXRestfulAPIApiService
	accountId       *int32
	billType        *string
	start           *int64
	end             *int64
	limit           *int32
	offset          *int32
	tokenId         *int32
	income          *bool
	transferAddress *string
	fromAddress     *string
}

func (r ApiGetUserBillV3Request) AccountId(accountId int32) ApiGetUserBillV3Request {
	r.accountId = &accountId
	return r
}

func (r ApiGetUserBillV3Request) BillType(billType string) ApiGetUserBillV3Request {
	r.billType = &billType
	return r
}

func (r ApiGetUserBillV3Request) Start(start int64) ApiGetUserBillV3Request {
	r.start = &start
	return r
}

func (r ApiGetUserBillV3Request) End(end int64) ApiGetUserBillV3Request {
	r.end = &end
	return r
}

func (r ApiGetUserBillV3Request) Limit(limit int32) ApiGetUserBillV3Request {
	r.limit = &limit
	return r
}

func (r ApiGetUserBillV3Request) Offset(offset int32) ApiGetUserBillV3Request {
	r.offset = &offset
	return r
}

func (r ApiGetUserBillV3Request) TokenId(tokenId int32) ApiGetUserBillV3Request {
	r.tokenId = &tokenId
	return r
}

func (r ApiGetUserBillV3Request) Income(income bool) ApiGetUserBillV3Request {
	r.income = &income
	return r
}

func (r ApiGetUserBillV3Request) TransferAddress(transferAddress string) ApiGetUserBillV3Request {
	r.transferAddress = &transferAddress
	return r
}

func (r ApiGetUserBillV3Request) FromAddress(fromAddress string) ApiGetUserBillV3Request {
	r.fromAddress = &fromAddress
	return r
}

func (r ApiGetUserBillV3Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetUserBillV3Execute(r)
}

/*
GetUserBillV3 Method for GetUserBillV3

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUserBillV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetUserBillV3(ctx context.Context) ApiGetUserBillV3Request {
	return ApiGetUserBillV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *LoopringDEXRestfulAPIApiService) GetUserBillV3Execute(r ApiGetUserBillV3Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetUserBillV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/user/bills"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.accountId != nil {
		localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	}
	if r.billType != nil {
		localVarQueryParams.Add("billType", parameterToString(*r.billType, ""))
	}
	if r.start != nil {
		localVarQueryParams.Add("start", parameterToString(*r.start, ""))
	}
	if r.end != nil {
		localVarQueryParams.Add("end", parameterToString(*r.end, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.tokenId != nil {
		localVarQueryParams.Add("tokenId", parameterToString(*r.tokenId, ""))
	}
	if r.income != nil {
		localVarQueryParams.Add("income", parameterToString(*r.income, ""))
	}
	if r.transferAddress != nil {
		localVarQueryParams.Add("transferAddress", parameterToString(*r.transferAddress, ""))
	}
	if r.fromAddress != nil {
		localVarQueryParams.Add("fromAddress", parameterToString(*r.fromAddress, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserCreateV2Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	accountId  *int32
	start      *int64
	end        *int64
	status     *string
	limit      *int32
	offset     *int64
}

// Account ID, some hash query APIs doesnt need it if in hash query mode, check require flag of each API to see if its a must.
func (r ApiGetUserCreateV2Request) AccountId(accountId int32) ApiGetUserCreateV2Request {
	r.accountId = &accountId
	return r
}

// Start time in milliseconds
func (r ApiGetUserCreateV2Request) Start(start int64) ApiGetUserCreateV2Request {
	r.start = &start
	return r
}

// End time in milliseconds
func (r ApiGetUserCreateV2Request) End(end int64) ApiGetUserCreateV2Request {
	r.end = &end
	return r
}

// Comma separated status values
func (r ApiGetUserCreateV2Request) Status(status string) ApiGetUserCreateV2Request {
	r.status = &status
	return r
}

// Number of records to return
func (r ApiGetUserCreateV2Request) Limit(limit int32) ApiGetUserCreateV2Request {
	r.limit = &limit
	return r
}

// Number of records to skip
func (r ApiGetUserCreateV2Request) Offset(offset int64) ApiGetUserCreateV2Request {
	r.offset = &offset
	return r
}

func (r ApiGetUserCreateV2Request) Execute() (*GetUserCreateResponseV2, *http.Response, error) {
	return r.ApiService.GetUserCreateV2Execute(r)
}

/*
GetUserCreateV2 Get user registration transactions

Returns a list Ethereum transactions from users for exchange account registration.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUserCreateV2Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetUserCreateV2(ctx context.Context) ApiGetUserCreateV2Request {
	return ApiGetUserCreateV2Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GetUserCreateResponseV2
func (a *LoopringDEXRestfulAPIApiService) GetUserCreateV2Execute(r ApiGetUserCreateV2Request) (*GetUserCreateResponseV2, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetUserCreateResponseV2
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetUserCreateV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/user/createInfo"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}

	localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	if r.start != nil {
		localVarQueryParams.Add("start", parameterToString(*r.start, ""))
	}
	if r.end != nil {
		localVarQueryParams.Add("end", parameterToString(*r.end, ""))
	}
	if r.status != nil {
		localVarQueryParams.Add("status", parameterToString(*r.status, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserCreateV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	accountId  *int32
	start      *int64
	end        *int64
	status     *string
	limit      *int32
	offset     *int64
}

// Account ID, some hash query APIs doesnt need it if in hash query mode, check require flag of each API to see if its a must.
func (r ApiGetUserCreateV3Request) AccountId(accountId int32) ApiGetUserCreateV3Request {
	r.accountId = &accountId
	return r
}

// Start time in milliseconds
func (r ApiGetUserCreateV3Request) Start(start int64) ApiGetUserCreateV3Request {
	r.start = &start
	return r
}

// End time in milliseconds
func (r ApiGetUserCreateV3Request) End(end int64) ApiGetUserCreateV3Request {
	r.end = &end
	return r
}

// Comma separated status values
func (r ApiGetUserCreateV3Request) Status(status string) ApiGetUserCreateV3Request {
	r.status = &status
	return r
}

// Number of records to return
func (r ApiGetUserCreateV3Request) Limit(limit int32) ApiGetUserCreateV3Request {
	r.limit = &limit
	return r
}

// Number of records to skip
func (r ApiGetUserCreateV3Request) Offset(offset int64) ApiGetUserCreateV3Request {
	r.offset = &offset
	return r
}

func (r ApiGetUserCreateV3Request) Execute() (*UserCreateDataList, *http.Response, error) {
	return r.ApiService.GetUserCreateV3Execute(r)
}

/*
GetUserCreateV3 Get user registration transactions

Returns a list Ethereum transactions from users for exchange account registration.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUserCreateV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetUserCreateV3(ctx context.Context) ApiGetUserCreateV3Request {
	return ApiGetUserCreateV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return UserCreateDataList
func (a *LoopringDEXRestfulAPIApiService) GetUserCreateV3Execute(r ApiGetUserCreateV3Request) (*UserCreateDataList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UserCreateDataList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetUserCreateV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/user/createInfo"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}

	localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	if r.start != nil {
		localVarQueryParams.Add("start", parameterToString(*r.start, ""))
	}
	if r.end != nil {
		localVarQueryParams.Add("end", parameterToString(*r.end, ""))
	}
	if r.status != nil {
		localVarQueryParams.Add("status", parameterToString(*r.status, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserDepositsV2Request struct {
	ctx         context.Context
	ApiService  *LoopringDEXRestfulAPIApiService
	accountId   *int32
	start       *int64
	end         *int64
	status      *string
	limit       *int32
	tokenSymbol *string
	offset      *int64
}

// Account ID, some hash query APIs doesnt need it if in hash query mode, check require flag of each API to see if its a must.
func (r ApiGetUserDepositsV2Request) AccountId(accountId int32) ApiGetUserDepositsV2Request {
	r.accountId = &accountId
	return r
}

// Start time in milliseconds
func (r ApiGetUserDepositsV2Request) Start(start int64) ApiGetUserDepositsV2Request {
	r.start = &start
	return r
}

// End time in milliseconds
func (r ApiGetUserDepositsV2Request) End(end int64) ApiGetUserDepositsV2Request {
	r.end = &end
	return r
}

// Comma separated status values
func (r ApiGetUserDepositsV2Request) Status(status string) ApiGetUserDepositsV2Request {
	r.status = &status
	return r
}

// Number of records to return
func (r ApiGetUserDepositsV2Request) Limit(limit int32) ApiGetUserDepositsV2Request {
	r.limit = &limit
	return r
}

// Token to filter. If you want to return deposit records for all tokens, omit this parameter
func (r ApiGetUserDepositsV2Request) TokenSymbol(tokenSymbol string) ApiGetUserDepositsV2Request {
	r.tokenSymbol = &tokenSymbol
	return r
}

// Number of records to skip
func (r ApiGetUserDepositsV2Request) Offset(offset int64) ApiGetUserDepositsV2Request {
	r.offset = &offset
	return r
}

func (r ApiGetUserDepositsV2Request) Execute() (*GetUserDepositResponseV2, *http.Response, error) {
	return r.ApiService.GetUserDepositsV2Execute(r)
}

/*
GetUserDepositsV2 Get user deposit history

Returns a list of deposit records for the given user.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUserDepositsV2Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetUserDepositsV2(ctx context.Context) ApiGetUserDepositsV2Request {
	return ApiGetUserDepositsV2Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GetUserDepositResponseV2
func (a *LoopringDEXRestfulAPIApiService) GetUserDepositsV2Execute(r ApiGetUserDepositsV2Request) (*GetUserDepositResponseV2, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetUserDepositResponseV2
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetUserDepositsV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/user/deposits"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}

	localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	if r.start != nil {
		localVarQueryParams.Add("start", parameterToString(*r.start, ""))
	}
	if r.end != nil {
		localVarQueryParams.Add("end", parameterToString(*r.end, ""))
	}
	if r.status != nil {
		localVarQueryParams.Add("status", parameterToString(*r.status, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.tokenSymbol != nil {
		localVarQueryParams.Add("tokenSymbol", parameterToString(*r.tokenSymbol, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserDepositsV3Request struct {
	ctx         context.Context
	ApiService  *LoopringDEXRestfulAPIApiService
	accountId   *int64
	start       *int64
	end         *int64
	status      *string
	limit       *int32
	tokenSymbol *string
	offset      *int64
	hashes      *string
}

// Account ID, some hash query APIs doesnt need it if in hash query mode, check require flag of each API to see if its a must.
func (r ApiGetUserDepositsV3Request) AccountId(accountId int64) ApiGetUserDepositsV3Request {
	r.accountId = &accountId
	return r
}

// Start time in milliseconds
func (r ApiGetUserDepositsV3Request) Start(start int64) ApiGetUserDepositsV3Request {
	r.start = &start
	return r
}

// End time in milliseconds
func (r ApiGetUserDepositsV3Request) End(end int64) ApiGetUserDepositsV3Request {
	r.end = &end
	return r
}

// Comma separated status values
func (r ApiGetUserDepositsV3Request) Status(status string) ApiGetUserDepositsV3Request {
	r.status = &status
	return r
}

// Number of records to return
func (r ApiGetUserDepositsV3Request) Limit(limit int32) ApiGetUserDepositsV3Request {
	r.limit = &limit
	return r
}

// Token to filter. If you want to return deposit records for all tokens, omit this parameter
func (r ApiGetUserDepositsV3Request) TokenSymbol(tokenSymbol string) ApiGetUserDepositsV3Request {
	r.tokenSymbol = &tokenSymbol
	return r
}

// Number of records to skip
func (r ApiGetUserDepositsV3Request) Offset(offset int64) ApiGetUserDepositsV3Request {
	r.offset = &offset
	return r
}

// The hashes (split by ,) of the transactions, normally its L2 tx hash, except the deposit which uses L1 tx hash.
func (r ApiGetUserDepositsV3Request) Hashes(hashes string) ApiGetUserDepositsV3Request {
	r.hashes = &hashes
	return r
}

func (r ApiGetUserDepositsV3Request) Execute() (*DepositDataList, *http.Response, error) {
	return r.ApiService.GetUserDepositsV3Execute(r)
}

/*
GetUserDepositsV3 Get user deposit history

Returns a list of deposit records for the given user.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUserDepositsV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetUserDepositsV3(ctx context.Context) ApiGetUserDepositsV3Request {
	return ApiGetUserDepositsV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return DepositDataList
func (a *LoopringDEXRestfulAPIApiService) GetUserDepositsV3Execute(r ApiGetUserDepositsV3Request) (*DepositDataList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DepositDataList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetUserDepositsV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/user/deposits"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.accountId != nil {
		localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	}
	if r.start != nil {
		localVarQueryParams.Add("start", parameterToString(*r.start, ""))
	}
	if r.end != nil {
		localVarQueryParams.Add("end", parameterToString(*r.end, ""))
	}
	if r.status != nil {
		localVarQueryParams.Add("status", parameterToString(*r.status, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.tokenSymbol != nil {
		localVarQueryParams.Add("tokenSymbol", parameterToString(*r.tokenSymbol, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.hashes != nil {
		localVarQueryParams.Add("hashes", parameterToString(*r.hashes, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserFeeRates2V2Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	accountId  *int32
	market     *string
	tokenB     *int32
	amountB    *string
}

// Account ID
func (r ApiGetUserFeeRates2V2Request) AccountId(accountId int32) ApiGetUserFeeRates2V2Request {
	r.accountId = &accountId
	return r
}

// List of markets to be queried separated by \&quot;,\&quot;
func (r ApiGetUserFeeRates2V2Request) Market(market string) ApiGetUserFeeRates2V2Request {
	r.market = &market
	return r
}

// Token ID
func (r ApiGetUserFeeRates2V2Request) TokenB(tokenB int32) ApiGetUserFeeRates2V2Request {
	r.tokenB = &tokenB
	return r
}

// Amount to buy
func (r ApiGetUserFeeRates2V2Request) AmountB(amountB string) ApiGetUserFeeRates2V2Request {
	r.amountB = &amountB
	return r
}

func (r ApiGetUserFeeRates2V2Request) Execute() (*GetUserFeeRates2Request, *http.Response, error) {
	return r.ApiService.GetUserFeeRates2V2Execute(r)
}

/*
GetUserFeeRates2V2 Query user place order fee rate

Returns the fee rate of users placing orders in specific markets

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUserFeeRates2V2Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetUserFeeRates2V2(ctx context.Context) ApiGetUserFeeRates2V2Request {
	return ApiGetUserFeeRates2V2Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GetUserFeeRates2Request
func (a *LoopringDEXRestfulAPIApiService) GetUserFeeRates2V2Execute(r ApiGetUserFeeRates2V2Request) (*GetUserFeeRates2Request, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetUserFeeRates2Request
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetUserFeeRates2V2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/user/orderFee"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.market == nil {
		return localVarReturnValue, nil, reportError("market is required and must be specified")
	}
	if r.tokenB == nil {
		return localVarReturnValue, nil, reportError("tokenB is required and must be specified")
	}
	if r.amountB == nil {
		return localVarReturnValue, nil, reportError("amountB is required and must be specified")
	}

	localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	localVarQueryParams.Add("market", parameterToString(*r.market, ""))
	localVarQueryParams.Add("tokenB", parameterToString(*r.tokenB, ""))
	localVarQueryParams.Add("amountB", parameterToString(*r.amountB, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserFeeRates2V3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	accountId  *int32
	market     *string
	tokenB     *int32
	amountB    *string
}

// Account ID
func (r ApiGetUserFeeRates2V3Request) AccountId(accountId int32) ApiGetUserFeeRates2V3Request {
	r.accountId = &accountId
	return r
}

// List of markets to be queried separated by \&quot;,\&quot;
func (r ApiGetUserFeeRates2V3Request) Market(market string) ApiGetUserFeeRates2V3Request {
	r.market = &market
	return r
}

// Token ID
func (r ApiGetUserFeeRates2V3Request) TokenB(tokenB int32) ApiGetUserFeeRates2V3Request {
	r.tokenB = &tokenB
	return r
}

// Amount to buy
func (r ApiGetUserFeeRates2V3Request) AmountB(amountB string) ApiGetUserFeeRates2V3Request {
	r.amountB = &amountB
	return r
}

func (r ApiGetUserFeeRates2V3Request) Execute() (*GetUserFeeRatesResponseData, *http.Response, error) {
	return r.ApiService.GetUserFeeRates2V3Execute(r)
}

/*
GetUserFeeRates2V3 Query user place order fee rate

Returns the fee rate of users placing orders in specific markets

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUserFeeRates2V3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetUserFeeRates2V3(ctx context.Context) ApiGetUserFeeRates2V3Request {
	return ApiGetUserFeeRates2V3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GetUserFeeRatesResponseData
func (a *LoopringDEXRestfulAPIApiService) GetUserFeeRates2V3Execute(r ApiGetUserFeeRates2V3Request) (*GetUserFeeRatesResponseData, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetUserFeeRatesResponseData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetUserFeeRates2V3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/user/orderFee"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.market == nil {
		return localVarReturnValue, nil, reportError("market is required and must be specified")
	}
	if r.tokenB == nil {
		return localVarReturnValue, nil, reportError("tokenB is required and must be specified")
	}
	if r.amountB == nil {
		return localVarReturnValue, nil, reportError("amountB is required and must be specified")
	}

	localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	localVarQueryParams.Add("market", parameterToString(*r.market, ""))
	localVarQueryParams.Add("tokenB", parameterToString(*r.tokenB, ""))
	localVarQueryParams.Add("amountB", parameterToString(*r.amountB, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserNftBalancesV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	accountId  *int64
	nftDatas   *string
	tokenAddrs *string
	tokenIds   *string
	offset     *int64
	limit      *int32
	nonZero    *bool
}

// AccountID
func (r ApiGetUserNftBalancesV3Request) AccountId(accountId int64) ApiGetUserNftBalancesV3Request {
	r.accountId = &accountId
	return r
}

// The Loopring&#39;s NFT token data identifier which is a hash string of NFT token address and NFT_ID
func (r ApiGetUserNftBalancesV3Request) NftDatas(nftDatas string) ApiGetUserNftBalancesV3Request {
	r.nftDatas = &nftDatas
	return r
}

// NFT token address
func (r ApiGetUserNftBalancesV3Request) TokenAddrs(tokenAddrs string) ApiGetUserNftBalancesV3Request {
	r.tokenAddrs = &tokenAddrs
	return r
}

// The token slot ID in loopring DEX.
func (r ApiGetUserNftBalancesV3Request) TokenIds(tokenIds string) ApiGetUserNftBalancesV3Request {
	r.tokenIds = &tokenIds
	return r
}

// Number of records to skip
func (r ApiGetUserNftBalancesV3Request) Offset(offset int64) ApiGetUserNftBalancesV3Request {
	r.offset = &offset
	return r
}

// Number of records to return
func (r ApiGetUserNftBalancesV3Request) Limit(limit int32) ApiGetUserNftBalancesV3Request {
	r.limit = &limit
	return r
}

// Hide 0 balance NFT token, default is true
func (r ApiGetUserNftBalancesV3Request) NonZero(nonZero bool) ApiGetUserNftBalancesV3Request {
	r.nonZero = &nonZero
	return r
}

func (r ApiGetUserNftBalancesV3Request) Execute() (*GetUserNftBalancesResponse, *http.Response, error) {
	return r.ApiService.GetUserNftBalancesV3Execute(r)
}

/*
GetUserNftBalancesV3 Get users NFT balance

Get users NFT balance, besides amount, it also includes tokenId and nftData

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUserNftBalancesV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetUserNftBalancesV3(ctx context.Context) ApiGetUserNftBalancesV3Request {
	return ApiGetUserNftBalancesV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GetUserNftBalancesResponse
func (a *LoopringDEXRestfulAPIApiService) GetUserNftBalancesV3Execute(r ApiGetUserNftBalancesV3Request) (*GetUserNftBalancesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetUserNftBalancesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetUserNftBalancesV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/user/nft/balances"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}

	localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	if r.nftDatas != nil {
		localVarQueryParams.Add("nftDatas", parameterToString(*r.nftDatas, ""))
	}
	if r.tokenAddrs != nil {
		localVarQueryParams.Add("tokenAddrs", parameterToString(*r.tokenAddrs, ""))
	}
	if r.tokenIds != nil {
		localVarQueryParams.Add("tokenIds", parameterToString(*r.tokenIds, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.nonZero != nil {
		localVarQueryParams.Add("nonZero", parameterToString(*r.nonZero, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserNftMintsV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	accountId  *int64
	nftData    *string
	start      *int64
	end        *int64
	startId    *int64
	limit      *int32
	txStatus   *string
	hashes     *string
}

// users accountId.
func (r ApiGetUserNftMintsV3Request) AccountId(accountId int64) ApiGetUserNftMintsV3Request {
	r.accountId = &accountId
	return r
}

// the nftData of the NFT token
func (r ApiGetUserNftMintsV3Request) NftData(nftData string) ApiGetUserNftMintsV3Request {
	r.nftData = &nftData
	return r
}

// Start time in milliseconds
func (r ApiGetUserNftMintsV3Request) Start(start int64) ApiGetUserNftMintsV3Request {
	r.start = &start
	return r
}

// End time in milliseconds
func (r ApiGetUserNftMintsV3Request) End(end int64) ApiGetUserNftMintsV3Request {
	r.end = &end
	return r
}

// The begin id of the query.
func (r ApiGetUserNftMintsV3Request) StartId(startId int64) ApiGetUserNftMintsV3Request {
	r.startId = &startId
	return r
}

// Number of records to return
func (r ApiGetUserNftMintsV3Request) Limit(limit int32) ApiGetUserNftMintsV3Request {
	r.limit = &limit
	return r
}

// The mint status
func (r ApiGetUserNftMintsV3Request) TxStatus(txStatus string) ApiGetUserNftMintsV3Request {
	r.txStatus = &txStatus
	return r
}

// The hashes (split by ,) of the transactions, normally its L2 tx hash, except the deposit which uses L1 tx hash.
func (r ApiGetUserNftMintsV3Request) Hashes(hashes string) ApiGetUserNftMintsV3Request {
	r.hashes = &hashes
	return r
}

func (r ApiGetUserNftMintsV3Request) Execute() (*GetUserNftMintsResponse, *http.Response, error) {
	return r.ApiService.GetUserNftMintsV3Execute(r)
}

/*
GetUserNftMintsV3 Get user NFT mint history

Returns a list of NFT mint records for the given user.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUserNftMintsV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetUserNftMintsV3(ctx context.Context) ApiGetUserNftMintsV3Request {
	return ApiGetUserNftMintsV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GetUserNftMintsResponse
func (a *LoopringDEXRestfulAPIApiService) GetUserNftMintsV3Execute(r ApiGetUserNftMintsV3Request) (*GetUserNftMintsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetUserNftMintsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetUserNftMintsV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/user/nft/mints"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}

	localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	if r.nftData != nil {
		localVarQueryParams.Add("nftData", parameterToString(*r.nftData, ""))
	}
	if r.start != nil {
		localVarQueryParams.Add("start", parameterToString(*r.start, ""))
	}
	if r.end != nil {
		localVarQueryParams.Add("end", parameterToString(*r.end, ""))
	}
	if r.startId != nil {
		localVarQueryParams.Add("startId", parameterToString(*r.startId, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.txStatus != nil {
		localVarQueryParams.Add("txStatus", parameterToString(*r.txStatus, ""))
	}
	if r.hashes != nil {
		localVarQueryParams.Add("hashes", parameterToString(*r.hashes, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserNftOrderFeeRatesV3Request struct {
	ctx             context.Context
	ApiService      *LoopringDEXRestfulAPIApiService
	accountId       *int32
	nftTokenAddress *string
	quoteToken      *int32
	quoteAmount     *string
}

// Account ID
func (r ApiGetUserNftOrderFeeRatesV3Request) AccountId(accountId int32) ApiGetUserNftOrderFeeRatesV3Request {
	r.accountId = &accountId
	return r
}

// NFT token address of order
func (r ApiGetUserNftOrderFeeRatesV3Request) NftTokenAddress(nftTokenAddress string) ApiGetUserNftOrderFeeRatesV3Request {
	r.nftTokenAddress = &nftTokenAddress
	return r
}

// the quote token of the NFT-Quote market
func (r ApiGetUserNftOrderFeeRatesV3Request) QuoteToken(quoteToken int32) ApiGetUserNftOrderFeeRatesV3Request {
	r.quoteToken = &quoteToken
	return r
}

// request.getUserFeeRates.quoteAmount
func (r ApiGetUserNftOrderFeeRatesV3Request) QuoteAmount(quoteAmount string) ApiGetUserNftOrderFeeRatesV3Request {
	r.quoteAmount = &quoteAmount
	return r
}

func (r ApiGetUserNftOrderFeeRatesV3Request) Execute() (*GetUserNftFeeRatesResponse, *http.Response, error) {
	return r.ApiService.GetUserNftOrderFeeRatesV3Execute(r)
}

/*
GetUserNftOrderFeeRatesV3 Query user place order fee rate

Returns the fee rate of users placing orders in specific markets

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUserNftOrderFeeRatesV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetUserNftOrderFeeRatesV3(ctx context.Context) ApiGetUserNftOrderFeeRatesV3Request {
	return ApiGetUserNftOrderFeeRatesV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GetUserNftFeeRatesResponse
func (a *LoopringDEXRestfulAPIApiService) GetUserNftOrderFeeRatesV3Execute(r ApiGetUserNftOrderFeeRatesV3Request) (*GetUserNftFeeRatesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetUserNftFeeRatesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetUserNftOrderFeeRatesV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/user/nft/orderFee"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.nftTokenAddress == nil {
		return localVarReturnValue, nil, reportError("nftTokenAddress is required and must be specified")
	}
	if r.quoteToken == nil {
		return localVarReturnValue, nil, reportError("quoteToken is required and must be specified")
	}
	if r.quoteAmount == nil {
		return localVarReturnValue, nil, reportError("quoteAmount is required and must be specified")
	}

	localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	localVarQueryParams.Add("nftTokenAddress", parameterToString(*r.nftTokenAddress, ""))
	localVarQueryParams.Add("quoteToken", parameterToString(*r.quoteToken, ""))
	localVarQueryParams.Add("quoteAmount", parameterToString(*r.quoteAmount, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserNftTransactionsV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	accountId  *int64
	start      *int64
	end        *int64
	limit      *int32
	offset     *int64
	nftData    *string
	txStatus   *string
	types      *string
	hashes     *string
}

// request.getUserNftTransactions.accountId
func (r ApiGetUserNftTransactionsV3Request) AccountId(accountId int64) ApiGetUserNftTransactionsV3Request {
	r.accountId = &accountId
	return r
}

// request.getUserNftTransactions.start
func (r ApiGetUserNftTransactionsV3Request) Start(start int64) ApiGetUserNftTransactionsV3Request {
	r.start = &start
	return r
}

// request.getUserNftTransactions.end
func (r ApiGetUserNftTransactionsV3Request) End(end int64) ApiGetUserNftTransactionsV3Request {
	r.end = &end
	return r
}

// request.getUserNftTransactions.limit
func (r ApiGetUserNftTransactionsV3Request) Limit(limit int32) ApiGetUserNftTransactionsV3Request {
	r.limit = &limit
	return r
}

// request.getUserNftTransactions.offset
func (r ApiGetUserNftTransactionsV3Request) Offset(offset int64) ApiGetUserNftTransactionsV3Request {
	r.offset = &offset
	return r
}

// request.getUserNftTransactions.nftHash
func (r ApiGetUserNftTransactionsV3Request) NftData(nftData string) ApiGetUserNftTransactionsV3Request {
	r.nftData = &nftData
	return r
}

// request.getUserNftTransactions.txStatus
func (r ApiGetUserNftTransactionsV3Request) TxStatus(txStatus string) ApiGetUserNftTransactionsV3Request {
	r.txStatus = &txStatus
	return r
}

// request.getUserNftTransactions.types
func (r ApiGetUserNftTransactionsV3Request) Types(types string) ApiGetUserNftTransactionsV3Request {
	r.types = &types
	return r
}

// request.getUserNftTransactions.hashes
func (r ApiGetUserNftTransactionsV3Request) Hashes(hashes string) ApiGetUserNftTransactionsV3Request {
	r.hashes = &hashes
	return r
}

func (r ApiGetUserNftTransactionsV3Request) Execute() (*GetUserNftTxsResponseV2, *http.Response, error) {
	return r.ApiService.GetUserNftTransactionsV3Execute(r)
}

/*
GetUserNftTransactionsV3 api.getUserNftTransactions.value

api.getUserNftTransactions.notes

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUserNftTransactionsV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetUserNftTransactionsV3(ctx context.Context) ApiGetUserNftTransactionsV3Request {
	return ApiGetUserNftTransactionsV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GetUserNftTxsResponseV2
func (a *LoopringDEXRestfulAPIApiService) GetUserNftTransactionsV3Execute(r ApiGetUserNftTransactionsV3Request) (*GetUserNftTxsResponseV2, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetUserNftTxsResponseV2
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetUserNftTransactionsV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/user/nft/transactions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}

	localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	if r.start != nil {
		localVarQueryParams.Add("start", parameterToString(*r.start, ""))
	}
	if r.end != nil {
		localVarQueryParams.Add("end", parameterToString(*r.end, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.nftData != nil {
		localVarQueryParams.Add("nftData", parameterToString(*r.nftData, ""))
	}
	if r.txStatus != nil {
		localVarQueryParams.Add("txStatus", parameterToString(*r.txStatus, ""))
	}
	if r.types != nil {
		localVarQueryParams.Add("types", parameterToString(*r.types, ""))
	}
	if r.hashes != nil {
		localVarQueryParams.Add("hashes", parameterToString(*r.hashes, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserRewardsV2Request struct {
	ctx            context.Context
	ApiService     *LoopringDEXRestfulAPIApiService
	owner          *int64
	ammPoolMarkets *string
}

func (r ApiGetUserRewardsV2Request) Owner(owner int64) ApiGetUserRewardsV2Request {
	r.owner = &owner
	return r
}

func (r ApiGetUserRewardsV2Request) AmmPoolMarkets(ammPoolMarkets string) ApiGetUserRewardsV2Request {
	r.ammPoolMarkets = &ammPoolMarkets
	return r
}

func (r ApiGetUserRewardsV2Request) Execute() (*GetAmmPoolsStatsResponse, *http.Response, error) {
	return r.ApiService.GetUserRewardsV2Execute(r)
}

/*
GetUserRewardsV2 api.getPoolsStats.value

api.getPoolsStats.notes

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUserRewardsV2Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetUserRewardsV2(ctx context.Context) ApiGetUserRewardsV2Request {
	return ApiGetUserRewardsV2Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GetAmmPoolsStatsResponse
func (a *LoopringDEXRestfulAPIApiService) GetUserRewardsV2Execute(r ApiGetUserRewardsV2Request) (*GetAmmPoolsStatsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetAmmPoolsStatsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetUserRewardsV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/amm/user/rewards"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.owner != nil {
		localVarQueryParams.Add("owner", parameterToString(*r.owner, ""))
	}
	if r.ammPoolMarkets != nil {
		localVarQueryParams.Add("ammPoolMarkets", parameterToString(*r.ammPoolMarkets, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserRewardsV3Request struct {
	ctx            context.Context
	ApiService     *LoopringDEXRestfulAPIApiService
	owner          *int64
	ammPoolMarkets *string
}

func (r ApiGetUserRewardsV3Request) Owner(owner int64) ApiGetUserRewardsV3Request {
	r.owner = &owner
	return r
}

func (r ApiGetUserRewardsV3Request) AmmPoolMarkets(ammPoolMarkets string) ApiGetUserRewardsV3Request {
	r.ammPoolMarkets = &ammPoolMarkets
	return r
}

func (r ApiGetUserRewardsV3Request) Execute() (*GetAmmPoolsStatsResponse, *http.Response, error) {
	return r.ApiService.GetUserRewardsV3Execute(r)
}

/*
GetUserRewardsV3 api.getPoolsStats.value

api.getPoolsStats.notes

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUserRewardsV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetUserRewardsV3(ctx context.Context) ApiGetUserRewardsV3Request {
	return ApiGetUserRewardsV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GetAmmPoolsStatsResponse
func (a *LoopringDEXRestfulAPIApiService) GetUserRewardsV3Execute(r ApiGetUserRewardsV3Request) (*GetAmmPoolsStatsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetAmmPoolsStatsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetUserRewardsV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/amm/user/rewards"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.owner != nil {
		localVarQueryParams.Add("owner", parameterToString(*r.owner, ""))
	}
	if r.ammPoolMarkets != nil {
		localVarQueryParams.Add("ammPoolMarkets", parameterToString(*r.ammPoolMarkets, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserTournamentRankV3Request struct {
	ctx           context.Context
	ApiService    *LoopringDEXRestfulAPIApiService
	owner         *string
	ammPoolMarket *string
}

func (r ApiGetUserTournamentRankV3Request) Owner(owner string) ApiGetUserTournamentRankV3Request {
	r.owner = &owner
	return r
}

func (r ApiGetUserTournamentRankV3Request) AmmPoolMarket(ammPoolMarket string) ApiGetUserTournamentRankV3Request {
	r.ammPoolMarket = &ammPoolMarket
	return r
}

func (r ApiGetUserTournamentRankV3Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetUserTournamentRankV3Execute(r)
}

/*
GetUserTournamentRankV3 Method for GetUserTournamentRankV3

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUserTournamentRankV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetUserTournamentRankV3(ctx context.Context) ApiGetUserTournamentRankV3Request {
	return ApiGetUserTournamentRankV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *LoopringDEXRestfulAPIApiService) GetUserTournamentRankV3Execute(r ApiGetUserTournamentRankV3Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetUserTournamentRankV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/game/user/rank"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.owner != nil {
		localVarQueryParams.Add("owner", parameterToString(*r.owner, ""))
	}
	if r.ammPoolMarket != nil {
		localVarQueryParams.Add("ammPoolMarket", parameterToString(*r.ammPoolMarket, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserTradeAmountV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	accountId  *int64
	markets    *string
	limit      *int32
}

func (r ApiGetUserTradeAmountV3Request) AccountId(accountId int64) ApiGetUserTradeAmountV3Request {
	r.accountId = &accountId
	return r
}

func (r ApiGetUserTradeAmountV3Request) Markets(markets string) ApiGetUserTradeAmountV3Request {
	r.markets = &markets
	return r
}

func (r ApiGetUserTradeAmountV3Request) Limit(limit int32) ApiGetUserTradeAmountV3Request {
	r.limit = &limit
	return r
}

func (r ApiGetUserTradeAmountV3Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetUserTradeAmountV3Execute(r)
}

/*
GetUserTradeAmountV3 Method for GetUserTradeAmountV3

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUserTradeAmountV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetUserTradeAmountV3(ctx context.Context) ApiGetUserTradeAmountV3Request {
	return ApiGetUserTradeAmountV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *LoopringDEXRestfulAPIApiService) GetUserTradeAmountV3Execute(r ApiGetUserTradeAmountV3Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetUserTradeAmountV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/datacenter/getUserTradeAmount"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.accountId != nil {
		localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	}
	if r.markets != nil {
		localVarQueryParams.Add("markets", parameterToString(*r.markets, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserTradesV2Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	accountId  *int32
	market     *string
	orderHash  *string
	offset     *int32
	limit      *int32
	fromId     *int64
	fillTypes  *string
}

// Account ID, some hash query APIs doesnt need it if in hash query mode, check require flag of each API to see if its a must.
func (r ApiGetUserTradesV2Request) AccountId(accountId int32) ApiGetUserTradesV2Request {
	r.accountId = &accountId
	return r
}

// Trading pair
func (r ApiGetUserTradesV2Request) Market(market string) ApiGetUserTradesV2Request {
	r.market = &market
	return r
}

// If a value is provided, only returns the trades associated with the given order
func (r ApiGetUserTradesV2Request) OrderHash(orderHash string) ApiGetUserTradesV2Request {
	r.orderHash = &orderHash
	return r
}

// Number of records to skip
func (r ApiGetUserTradesV2Request) Offset(offset int32) ApiGetUserTradesV2Request {
	r.offset = &offset
	return r
}

// Number of records to return
func (r ApiGetUserTradesV2Request) Limit(limit int32) ApiGetUserTradesV2Request {
	r.limit = &limit
	return r
}

// Pagination of data to return records earlier than the requested ID
func (r ApiGetUserTradesV2Request) FromId(fromId int64) ApiGetUserTradesV2Request {
	r.fromId = &fromId
	return r
}

// request.getUserTrades.fillTypes
func (r ApiGetUserTradesV2Request) FillTypes(fillTypes string) ApiGetUserTradesV2Request {
	r.fillTypes = &fillTypes
	return r
}

func (r ApiGetUserTradesV2Request) Execute() (*GetUserTradesResponseV2, *http.Response, error) {
	return r.ApiService.GetUserTradesV2Execute(r)
}

/*
GetUserTradesV2 Get user trade history

Get user trade history.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUserTradesV2Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetUserTradesV2(ctx context.Context) ApiGetUserTradesV2Request {
	return ApiGetUserTradesV2Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GetUserTradesResponseV2
func (a *LoopringDEXRestfulAPIApiService) GetUserTradesV2Execute(r ApiGetUserTradesV2Request) (*GetUserTradesResponseV2, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetUserTradesResponseV2
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetUserTradesV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/user/trades"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}

	localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	if r.market != nil {
		localVarQueryParams.Add("market", parameterToString(*r.market, ""))
	}
	if r.orderHash != nil {
		localVarQueryParams.Add("orderHash", parameterToString(*r.orderHash, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.fromId != nil {
		localVarQueryParams.Add("fromId", parameterToString(*r.fromId, ""))
	}
	if r.fillTypes != nil {
		localVarQueryParams.Add("fillTypes", parameterToString(*r.fillTypes, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserTradesV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	accountId  *int32
	market     *string
	orderHash  *string
	offset     *int32
	limit      *int32
	fromId     *int64
	fillTypes  *string
}

// Account ID, some hash query APIs doesnt need it if in hash query mode, check require flag of each API to see if its a must.
func (r ApiGetUserTradesV3Request) AccountId(accountId int32) ApiGetUserTradesV3Request {
	r.accountId = &accountId
	return r
}

// Trading pair
func (r ApiGetUserTradesV3Request) Market(market string) ApiGetUserTradesV3Request {
	r.market = &market
	return r
}

// Order hash
func (r ApiGetUserTradesV3Request) OrderHash(orderHash string) ApiGetUserTradesV3Request {
	r.orderHash = &orderHash
	return r
}

// Number of records to skip
func (r ApiGetUserTradesV3Request) Offset(offset int32) ApiGetUserTradesV3Request {
	r.offset = &offset
	return r
}

// Number of records to return
func (r ApiGetUserTradesV3Request) Limit(limit int32) ApiGetUserTradesV3Request {
	r.limit = &limit
	return r
}

// The begin id of the query
func (r ApiGetUserTradesV3Request) FromId(fromId int64) ApiGetUserTradesV3Request {
	r.fromId = &fromId
	return r
}

// request.getUserTxs.fillTypes
func (r ApiGetUserTradesV3Request) FillTypes(fillTypes string) ApiGetUserTradesV3Request {
	r.fillTypes = &fillTypes
	return r
}

func (r ApiGetUserTradesV3Request) Execute() (*TradeList, *http.Response, error) {
	return r.ApiService.GetUserTradesV3Execute(r)
}

/*
GetUserTradesV3 Get user trade history

Get user trade history.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUserTradesV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetUserTradesV3(ctx context.Context) ApiGetUserTradesV3Request {
	return ApiGetUserTradesV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return TradeList
func (a *LoopringDEXRestfulAPIApiService) GetUserTradesV3Execute(r ApiGetUserTradesV3Request) (*TradeList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *TradeList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetUserTradesV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/user/trades"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}

	localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	if r.market != nil {
		localVarQueryParams.Add("market", parameterToString(*r.market, ""))
	}
	if r.orderHash != nil {
		localVarQueryParams.Add("orderHash", parameterToString(*r.orderHash, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.fromId != nil {
		localVarQueryParams.Add("fromId", parameterToString(*r.fromId, ""))
	}
	if r.fillTypes != nil {
		localVarQueryParams.Add("fillTypes", parameterToString(*r.fillTypes, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserTransactionsV3Request struct {
	ctx         context.Context
	ApiService  *LoopringDEXRestfulAPIApiService
	accountId   *int32
	start       *int64
	end         *int64
	limit       *int32
	tokenSymbol *string
	offset      *int64
	types       *string
	hashes      *string
}

// Account ID, some hash query APIs doesnt need it if in hash query mode, check require flag of each API to see if its a must.
func (r ApiGetUserTransactionsV3Request) AccountId(accountId int32) ApiGetUserTransactionsV3Request {
	r.accountId = &accountId
	return r
}

// Start time in milliseconds
func (r ApiGetUserTransactionsV3Request) Start(start int64) ApiGetUserTransactionsV3Request {
	r.start = &start
	return r
}

// End time in milliseconds
func (r ApiGetUserTransactionsV3Request) End(end int64) ApiGetUserTransactionsV3Request {
	r.end = &end
	return r
}

// Number of records to return
func (r ApiGetUserTransactionsV3Request) Limit(limit int32) ApiGetUserTransactionsV3Request {
	r.limit = &limit
	return r
}

// Token to filter. If you want to return deposit records for all tokens, omit this parameter
func (r ApiGetUserTransactionsV3Request) TokenSymbol(tokenSymbol string) ApiGetUserTransactionsV3Request {
	r.tokenSymbol = &tokenSymbol
	return r
}

// Number of records to skip
func (r ApiGetUserTransactionsV3Request) Offset(offset int64) ApiGetUserTransactionsV3Request {
	r.offset = &offset
	return r
}

// The type of the transactions to be queried
func (r ApiGetUserTransactionsV3Request) Types(types string) ApiGetUserTransactionsV3Request {
	r.types = &types
	return r
}

// The hashes (split by ,) of the transactions, normally its L2 tx hash, except the deposit which uses L1 tx hash.
func (r ApiGetUserTransactionsV3Request) Hashes(hashes string) ApiGetUserTransactionsV3Request {
	r.hashes = &hashes
	return r
}

func (r ApiGetUserTransactionsV3Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetUserTransactionsV3Execute(r)
}

/*
GetUserTransactionsV3 Method for GetUserTransactionsV3

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUserTransactionsV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetUserTransactionsV3(ctx context.Context) ApiGetUserTransactionsV3Request {
	return ApiGetUserTransactionsV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *LoopringDEXRestfulAPIApiService) GetUserTransactionsV3Execute(r ApiGetUserTransactionsV3Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetUserTransactionsV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/user/transactions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}

	localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	if r.start != nil {
		localVarQueryParams.Add("start", parameterToString(*r.start, ""))
	}
	if r.end != nil {
		localVarQueryParams.Add("end", parameterToString(*r.end, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.tokenSymbol != nil {
		localVarQueryParams.Add("tokenSymbol", parameterToString(*r.tokenSymbol, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.types != nil {
		localVarQueryParams.Add("types", parameterToString(*r.types, ""))
	}
	if r.hashes != nil {
		localVarQueryParams.Add("hashes", parameterToString(*r.hashes, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserTransfersV2Request struct {
	ctx           context.Context
	ApiService    *LoopringDEXRestfulAPIApiService
	accountId     *int32
	start         *int64
	end           *int64
	status        *string
	limit         *int32
	tokenSymbol   *string
	offset        *int64
	transferTypes *string
}

// Account ID, some hash query APIs doesnt need it if in hash query mode, check require flag of each API to see if its a must.
func (r ApiGetUserTransfersV2Request) AccountId(accountId int32) ApiGetUserTransfersV2Request {
	r.accountId = &accountId
	return r
}

// Start time in milliseconds
func (r ApiGetUserTransfersV2Request) Start(start int64) ApiGetUserTransfersV2Request {
	r.start = &start
	return r
}

// End time in milliseconds
func (r ApiGetUserTransfersV2Request) End(end int64) ApiGetUserTransfersV2Request {
	r.end = &end
	return r
}

// Comma separated status values
func (r ApiGetUserTransfersV2Request) Status(status string) ApiGetUserTransfersV2Request {
	r.status = &status
	return r
}

// Number of records to return
func (r ApiGetUserTransfersV2Request) Limit(limit int32) ApiGetUserTransfersV2Request {
	r.limit = &limit
	return r
}

// Token to filter. If you want to return deposit records for all tokens, omit this parameter
func (r ApiGetUserTransfersV2Request) TokenSymbol(tokenSymbol string) ApiGetUserTransfersV2Request {
	r.tokenSymbol = &tokenSymbol
	return r
}

// Number of records to skip
func (r ApiGetUserTransfersV2Request) Offset(offset int64) ApiGetUserTransfersV2Request {
	r.offset = &offset
	return r
}

// request.getUserTxs.transferTypes
func (r ApiGetUserTransfersV2Request) TransferTypes(transferTypes string) ApiGetUserTransfersV2Request {
	r.transferTypes = &transferTypes
	return r
}

func (r ApiGetUserTransfersV2Request) Execute() (*GetUserTransferResponse, *http.Response, error) {
	return r.ApiService.GetUserTransfersV2Execute(r)
}

/*
GetUserTransfersV2 Get user transfer list

Get user transfer list.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUserTransfersV2Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetUserTransfersV2(ctx context.Context) ApiGetUserTransfersV2Request {
	return ApiGetUserTransfersV2Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GetUserTransferResponse
func (a *LoopringDEXRestfulAPIApiService) GetUserTransfersV2Execute(r ApiGetUserTransfersV2Request) (*GetUserTransferResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetUserTransferResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetUserTransfersV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/user/transfers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}

	localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	if r.start != nil {
		localVarQueryParams.Add("start", parameterToString(*r.start, ""))
	}
	if r.end != nil {
		localVarQueryParams.Add("end", parameterToString(*r.end, ""))
	}
	if r.status != nil {
		localVarQueryParams.Add("status", parameterToString(*r.status, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.tokenSymbol != nil {
		localVarQueryParams.Add("tokenSymbol", parameterToString(*r.tokenSymbol, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.transferTypes != nil {
		localVarQueryParams.Add("transferTypes", parameterToString(*r.transferTypes, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserTransfersV3Request struct {
	ctx           context.Context
	ApiService    *LoopringDEXRestfulAPIApiService
	accountId     *int64
	start         *int64
	end           *int64
	status        *string
	limit         *int32
	tokenSymbol   *string
	offset        *int64
	transferTypes *string
	hashes        *string
}

// Account ID, some hash query APIs doesnt need it if in hash query mode, check require flag of each API to see if its a must.
func (r ApiGetUserTransfersV3Request) AccountId(accountId int64) ApiGetUserTransfersV3Request {
	r.accountId = &accountId
	return r
}

// Start time in milliseconds
func (r ApiGetUserTransfersV3Request) Start(start int64) ApiGetUserTransfersV3Request {
	r.start = &start
	return r
}

// End time in milliseconds
func (r ApiGetUserTransfersV3Request) End(end int64) ApiGetUserTransfersV3Request {
	r.end = &end
	return r
}

// Comma separated status values
func (r ApiGetUserTransfersV3Request) Status(status string) ApiGetUserTransfersV3Request {
	r.status = &status
	return r
}

// Number of records to return
func (r ApiGetUserTransfersV3Request) Limit(limit int32) ApiGetUserTransfersV3Request {
	r.limit = &limit
	return r
}

// Token to filter. If you want to return deposit records for all tokens, omit this parameter
func (r ApiGetUserTransfersV3Request) TokenSymbol(tokenSymbol string) ApiGetUserTransfersV3Request {
	r.tokenSymbol = &tokenSymbol
	return r
}

// Number of records to skip
func (r ApiGetUserTransfersV3Request) Offset(offset int64) ApiGetUserTransfersV3Request {
	r.offset = &offset
	return r
}

// request.getUserTxs.transferTypes
func (r ApiGetUserTransfersV3Request) TransferTypes(transferTypes string) ApiGetUserTransfersV3Request {
	r.transferTypes = &transferTypes
	return r
}

// The hashes (split by ,) of the transactions, normally its L2 tx hash, except the deposit which uses L1 tx hash.
func (r ApiGetUserTransfersV3Request) Hashes(hashes string) ApiGetUserTransfersV3Request {
	r.hashes = &hashes
	return r
}

func (r ApiGetUserTransfersV3Request) Execute() (*TransferDataList, *http.Response, error) {
	return r.ApiService.GetUserTransfersV3Execute(r)
}

/*
GetUserTransfersV3 Get user transfer list

Get user transfer list.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUserTransfersV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetUserTransfersV3(ctx context.Context) ApiGetUserTransfersV3Request {
	return ApiGetUserTransfersV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return TransferDataList
func (a *LoopringDEXRestfulAPIApiService) GetUserTransfersV3Execute(r ApiGetUserTransfersV3Request) (*TransferDataList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *TransferDataList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetUserTransfersV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/user/transfers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.accountId != nil {
		localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	}
	if r.start != nil {
		localVarQueryParams.Add("start", parameterToString(*r.start, ""))
	}
	if r.end != nil {
		localVarQueryParams.Add("end", parameterToString(*r.end, ""))
	}
	if r.status != nil {
		localVarQueryParams.Add("status", parameterToString(*r.status, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.tokenSymbol != nil {
		localVarQueryParams.Add("tokenSymbol", parameterToString(*r.tokenSymbol, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.transferTypes != nil {
		localVarQueryParams.Add("transferTypes", parameterToString(*r.transferTypes, ""))
	}
	if r.hashes != nil {
		localVarQueryParams.Add("hashes", parameterToString(*r.hashes, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserUpdateV2Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	accountId  *int32
	start      *int64
	end        *int64
	status     *string
	limit      *int32
	offset     *int64
}

// Account ID, some hash query APIs doesnt need it if in hash query mode, check require flag of each API to see if its a must.
func (r ApiGetUserUpdateV2Request) AccountId(accountId int32) ApiGetUserUpdateV2Request {
	r.accountId = &accountId
	return r
}

// Start time in milliseconds
func (r ApiGetUserUpdateV2Request) Start(start int64) ApiGetUserUpdateV2Request {
	r.start = &start
	return r
}

// End time in milliseconds
func (r ApiGetUserUpdateV2Request) End(end int64) ApiGetUserUpdateV2Request {
	r.end = &end
	return r
}

// Comma separated status values
func (r ApiGetUserUpdateV2Request) Status(status string) ApiGetUserUpdateV2Request {
	r.status = &status
	return r
}

// Number of records to return
func (r ApiGetUserUpdateV2Request) Limit(limit int32) ApiGetUserUpdateV2Request {
	r.limit = &limit
	return r
}

// Number of records to skip
func (r ApiGetUserUpdateV2Request) Offset(offset int64) ApiGetUserUpdateV2Request {
	r.offset = &offset
	return r
}

func (r ApiGetUserUpdateV2Request) Execute() (*GetUserAccountUpdateResponseV2, *http.Response, error) {
	return r.ApiService.GetUserUpdateV2Execute(r)
}

/*
GetUserUpdateV2 Get password reset transactions

Returns a list Ethereum transactions from users for resetting exchange passwords.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUserUpdateV2Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetUserUpdateV2(ctx context.Context) ApiGetUserUpdateV2Request {
	return ApiGetUserUpdateV2Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GetUserAccountUpdateResponseV2
func (a *LoopringDEXRestfulAPIApiService) GetUserUpdateV2Execute(r ApiGetUserUpdateV2Request) (*GetUserAccountUpdateResponseV2, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetUserAccountUpdateResponseV2
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetUserUpdateV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/user/updateInfo"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}

	localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	if r.start != nil {
		localVarQueryParams.Add("start", parameterToString(*r.start, ""))
	}
	if r.end != nil {
		localVarQueryParams.Add("end", parameterToString(*r.end, ""))
	}
	if r.status != nil {
		localVarQueryParams.Add("status", parameterToString(*r.status, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserUpdateV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	accountId  *int32
	start      *int64
	end        *int64
	status     *string
	limit      *int32
	offset     *int64
}

// Account ID, some hash query APIs doesnt need it if in hash query mode, check require flag of each API to see if its a must.
func (r ApiGetUserUpdateV3Request) AccountId(accountId int32) ApiGetUserUpdateV3Request {
	r.accountId = &accountId
	return r
}

// Start time in milliseconds
func (r ApiGetUserUpdateV3Request) Start(start int64) ApiGetUserUpdateV3Request {
	r.start = &start
	return r
}

// End time in milliseconds
func (r ApiGetUserUpdateV3Request) End(end int64) ApiGetUserUpdateV3Request {
	r.end = &end
	return r
}

// Comma separated status values
func (r ApiGetUserUpdateV3Request) Status(status string) ApiGetUserUpdateV3Request {
	r.status = &status
	return r
}

// Number of records to return
func (r ApiGetUserUpdateV3Request) Limit(limit int32) ApiGetUserUpdateV3Request {
	r.limit = &limit
	return r
}

// Number of records to skip
func (r ApiGetUserUpdateV3Request) Offset(offset int64) ApiGetUserUpdateV3Request {
	r.offset = &offset
	return r
}

func (r ApiGetUserUpdateV3Request) Execute() (*UserAccountUpdateDataList, *http.Response, error) {
	return r.ApiService.GetUserUpdateV3Execute(r)
}

/*
GetUserUpdateV3 Get password reset transactions

Returns a list Ethereum transactions from users for resetting exchange passwords.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUserUpdateV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetUserUpdateV3(ctx context.Context) ApiGetUserUpdateV3Request {
	return ApiGetUserUpdateV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return UserAccountUpdateDataList
func (a *LoopringDEXRestfulAPIApiService) GetUserUpdateV3Execute(r ApiGetUserUpdateV3Request) (*UserAccountUpdateDataList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UserAccountUpdateDataList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetUserUpdateV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/user/updateInfo"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}

	localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	if r.start != nil {
		localVarQueryParams.Add("start", parameterToString(*r.start, ""))
	}
	if r.end != nil {
		localVarQueryParams.Add("end", parameterToString(*r.end, ""))
	}
	if r.status != nil {
		localVarQueryParams.Add("status", parameterToString(*r.status, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserVipInfoV3Request struct {
	ctx         context.Context
	ApiService  *LoopringDEXRestfulAPIApiService
	userAddress *string
}

// request.getUserVipInfo.address
func (r ApiGetUserVipInfoV3Request) UserAddress(userAddress string) ApiGetUserVipInfoV3Request {
	r.userAddress = &userAddress
	return r
}

func (r ApiGetUserVipInfoV3Request) Execute() (*BalanceV3, *http.Response, error) {
	return r.ApiService.GetUserVipInfoV3Execute(r)
}

/*
GetUserVipInfoV3 api.getUserVipInfo.value

api.getUserVipInfo.notes

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUserVipInfoV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetUserVipInfoV3(ctx context.Context) ApiGetUserVipInfoV3Request {
	return ApiGetUserVipInfoV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return BalanceV3
func (a *LoopringDEXRestfulAPIApiService) GetUserVipInfoV3Execute(r ApiGetUserVipInfoV3Request) (*BalanceV3, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BalanceV3
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetUserVipInfoV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/user/vipInfo"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.userAddress == nil {
		return localVarReturnValue, nil, reportError("userAddress is required and must be specified")
	}

	localVarQueryParams.Add("userAddress", parameterToString(*r.userAddress, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserWithdrawalsV2Request struct {
	ctx             context.Context
	ApiService      *LoopringDEXRestfulAPIApiService
	accountId       *int32
	start           *int64
	end             *int64
	status          *string
	limit           *int32
	tokenSymbol     *string
	offset          *int64
	withdrawalTypes *string
}

// Account ID, some hash query APIs doesnt need it if in hash query mode, check require flag of each API to see if its a must.
func (r ApiGetUserWithdrawalsV2Request) AccountId(accountId int32) ApiGetUserWithdrawalsV2Request {
	r.accountId = &accountId
	return r
}

// Start time in milliseconds
func (r ApiGetUserWithdrawalsV2Request) Start(start int64) ApiGetUserWithdrawalsV2Request {
	r.start = &start
	return r
}

// End time in milliseconds
func (r ApiGetUserWithdrawalsV2Request) End(end int64) ApiGetUserWithdrawalsV2Request {
	r.end = &end
	return r
}

// Comma separated status values
func (r ApiGetUserWithdrawalsV2Request) Status(status string) ApiGetUserWithdrawalsV2Request {
	r.status = &status
	return r
}

// Number of records to return
func (r ApiGetUserWithdrawalsV2Request) Limit(limit int32) ApiGetUserWithdrawalsV2Request {
	r.limit = &limit
	return r
}

// Token to filter. If you want to return deposit records for all tokens, omit this parameter
func (r ApiGetUserWithdrawalsV2Request) TokenSymbol(tokenSymbol string) ApiGetUserWithdrawalsV2Request {
	r.tokenSymbol = &tokenSymbol
	return r
}

// Number of records to skip
func (r ApiGetUserWithdrawalsV2Request) Offset(offset int64) ApiGetUserWithdrawalsV2Request {
	r.offset = &offset
	return r
}

// request.getUserTxs.withdrawalTypes
func (r ApiGetUserWithdrawalsV2Request) WithdrawalTypes(withdrawalTypes string) ApiGetUserWithdrawalsV2Request {
	r.withdrawalTypes = &withdrawalTypes
	return r
}

func (r ApiGetUserWithdrawalsV2Request) Execute() (*GetUserOnchainWithdrawalResponseV2, *http.Response, error) {
	return r.ApiService.GetUserWithdrawalsV2Execute(r)
}

/*
GetUserWithdrawalsV2 Get user onchain withdrawal history

Get user onchain withdrawal history.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUserWithdrawalsV2Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetUserWithdrawalsV2(ctx context.Context) ApiGetUserWithdrawalsV2Request {
	return ApiGetUserWithdrawalsV2Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GetUserOnchainWithdrawalResponseV2
func (a *LoopringDEXRestfulAPIApiService) GetUserWithdrawalsV2Execute(r ApiGetUserWithdrawalsV2Request) (*GetUserOnchainWithdrawalResponseV2, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetUserOnchainWithdrawalResponseV2
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetUserWithdrawalsV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/user/withdrawals"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}

	localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	if r.start != nil {
		localVarQueryParams.Add("start", parameterToString(*r.start, ""))
	}
	if r.end != nil {
		localVarQueryParams.Add("end", parameterToString(*r.end, ""))
	}
	if r.status != nil {
		localVarQueryParams.Add("status", parameterToString(*r.status, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.tokenSymbol != nil {
		localVarQueryParams.Add("tokenSymbol", parameterToString(*r.tokenSymbol, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.withdrawalTypes != nil {
		localVarQueryParams.Add("withdrawalTypes", parameterToString(*r.withdrawalTypes, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserWithdrawalsV3Request struct {
	ctx             context.Context
	ApiService      *LoopringDEXRestfulAPIApiService
	accountId       *int64
	start           *int64
	end             *int64
	status          *string
	limit           *int32
	tokenSymbol     *string
	offset          *int64
	withdrawalTypes *string
	hashes          *string
}

// Account ID, some hash query APIs doesnt need it if in hash query mode, check require flag of each API to see if its a must.
func (r ApiGetUserWithdrawalsV3Request) AccountId(accountId int64) ApiGetUserWithdrawalsV3Request {
	r.accountId = &accountId
	return r
}

// Start time in milliseconds
func (r ApiGetUserWithdrawalsV3Request) Start(start int64) ApiGetUserWithdrawalsV3Request {
	r.start = &start
	return r
}

// End time in milliseconds
func (r ApiGetUserWithdrawalsV3Request) End(end int64) ApiGetUserWithdrawalsV3Request {
	r.end = &end
	return r
}

// Comma separated status values
func (r ApiGetUserWithdrawalsV3Request) Status(status string) ApiGetUserWithdrawalsV3Request {
	r.status = &status
	return r
}

// Number of records to return
func (r ApiGetUserWithdrawalsV3Request) Limit(limit int32) ApiGetUserWithdrawalsV3Request {
	r.limit = &limit
	return r
}

// Token to filter. If you want to return deposit records for all tokens, omit this parameter
func (r ApiGetUserWithdrawalsV3Request) TokenSymbol(tokenSymbol string) ApiGetUserWithdrawalsV3Request {
	r.tokenSymbol = &tokenSymbol
	return r
}

// Number of records to skip
func (r ApiGetUserWithdrawalsV3Request) Offset(offset int64) ApiGetUserWithdrawalsV3Request {
	r.offset = &offset
	return r
}

// request.getUserTxs.withdrawalTypes
func (r ApiGetUserWithdrawalsV3Request) WithdrawalTypes(withdrawalTypes string) ApiGetUserWithdrawalsV3Request {
	r.withdrawalTypes = &withdrawalTypes
	return r
}

// The hashes (split by ,) of the transactions, normally its L2 tx hash, except the deposit which uses L1 tx hash.
func (r ApiGetUserWithdrawalsV3Request) Hashes(hashes string) ApiGetUserWithdrawalsV3Request {
	r.hashes = &hashes
	return r
}

func (r ApiGetUserWithdrawalsV3Request) Execute() (*OnchainWithdrawalDataList, *http.Response, error) {
	return r.ApiService.GetUserWithdrawalsV3Execute(r)
}

/*
GetUserWithdrawalsV3 Get user onchain withdrawal history

Get user onchain withdrawal history.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUserWithdrawalsV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetUserWithdrawalsV3(ctx context.Context) ApiGetUserWithdrawalsV3Request {
	return ApiGetUserWithdrawalsV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return OnchainWithdrawalDataList
func (a *LoopringDEXRestfulAPIApiService) GetUserWithdrawalsV3Execute(r ApiGetUserWithdrawalsV3Request) (*OnchainWithdrawalDataList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *OnchainWithdrawalDataList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetUserWithdrawalsV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/user/withdrawals"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}

	localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	if r.start != nil {
		localVarQueryParams.Add("start", parameterToString(*r.start, ""))
	}
	if r.end != nil {
		localVarQueryParams.Add("end", parameterToString(*r.end, ""))
	}
	if r.status != nil {
		localVarQueryParams.Add("status", parameterToString(*r.status, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.tokenSymbol != nil {
		localVarQueryParams.Add("tokenSymbol", parameterToString(*r.tokenSymbol, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.withdrawalTypes != nil {
		localVarQueryParams.Add("withdrawalTypes", parameterToString(*r.withdrawalTypes, ""))
	}
	if r.hashes != nil {
		localVarQueryParams.Add("hashes", parameterToString(*r.hashes, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetWithdrawalAgentsV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	tokenId    *int32
	amount     *string
}

func (r ApiGetWithdrawalAgentsV3Request) TokenId(tokenId int32) ApiGetWithdrawalAgentsV3Request {
	r.tokenId = &tokenId
	return r
}

func (r ApiGetWithdrawalAgentsV3Request) Amount(amount string) ApiGetWithdrawalAgentsV3Request {
	r.amount = &amount
	return r
}

func (r ApiGetWithdrawalAgentsV3Request) Execute() (*AgentInfo, *http.Response, error) {
	return r.ApiService.GetWithdrawalAgentsV3Execute(r)
}

/*
GetWithdrawalAgentsV3 api.getWithdrawalAgents.value

api.getWithdrawalAgents.notes

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetWithdrawalAgentsV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) GetWithdrawalAgentsV3(ctx context.Context) ApiGetWithdrawalAgentsV3Request {
	return ApiGetWithdrawalAgentsV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return AgentInfo
func (a *LoopringDEXRestfulAPIApiService) GetWithdrawalAgentsV3Execute(r ApiGetWithdrawalAgentsV3Request) (*AgentInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AgentInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.GetWithdrawalAgentsV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/exchange/withdrawalAgents"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.tokenId != nil {
		localVarQueryParams.Add("tokenId", parameterToString(*r.tokenId, ""))
	}
	if r.amount != nil {
		localVarQueryParams.Add("amount", parameterToString(*r.amount, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOpenHebaoAccountV3HebaoRequest struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
}

func (r ApiOpenHebaoAccountV3HebaoRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.OpenHebaoAccountV3HebaoExecute(r)
}

/*
OpenHebaoAccountV3Hebao Method for OpenHebaoAccountV3Hebao

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiOpenHebaoAccountV3HebaoRequest
*/
func (a *LoopringDEXRestfulAPIApiService) OpenHebaoAccountV3Hebao(ctx context.Context) ApiOpenHebaoAccountV3HebaoRequest {
	return ApiOpenHebaoAccountV3HebaoRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *LoopringDEXRestfulAPIApiService) OpenHebaoAccountV3HebaoExecute(r ApiOpenHebaoAccountV3HebaoRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.OpenHebaoAccountV3Hebao")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/hebao/openAccount"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPrepareHebaoPayV3HebaoRequest struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
}

func (r ApiPrepareHebaoPayV3HebaoRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.PrepareHebaoPayV3HebaoExecute(r)
}

/*
PrepareHebaoPayV3Hebao Method for PrepareHebaoPayV3Hebao

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPrepareHebaoPayV3HebaoRequest
*/
func (a *LoopringDEXRestfulAPIApiService) PrepareHebaoPayV3Hebao(ctx context.Context) ApiPrepareHebaoPayV3HebaoRequest {
	return ApiPrepareHebaoPayV3HebaoRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *LoopringDEXRestfulAPIApiService) PrepareHebaoPayV3HebaoExecute(r ApiPrepareHebaoPayV3HebaoRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.PrepareHebaoPayV3Hebao")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/hebao/preparePay"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRefundHebaoPayV3HebaoRequest struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
}

func (r ApiRefundHebaoPayV3HebaoRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.RefundHebaoPayV3HebaoExecute(r)
}

/*
RefundHebaoPayV3Hebao Method for RefundHebaoPayV3Hebao

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRefundHebaoPayV3HebaoRequest
*/
func (a *LoopringDEXRestfulAPIApiService) RefundHebaoPayV3Hebao(ctx context.Context) ApiRefundHebaoPayV3HebaoRequest {
	return ApiRefundHebaoPayV3HebaoRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *LoopringDEXRestfulAPIApiService) RefundHebaoPayV3HebaoExecute(r ApiRefundHebaoPayV3HebaoRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.RefundHebaoPayV3Hebao")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/hebao/refundPay"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchTokenMetadataV2Request struct {
	ctx            context.Context
	ApiService     *LoopringDEXRestfulAPIApiService
	tokenAddresses *string
	network        *string
}

// token address to be queried
func (r ApiSearchTokenMetadataV2Request) TokenAddresses(tokenAddresses string) ApiSearchTokenMetadataV2Request {
	r.tokenAddresses = &tokenAddresses
	return r
}

// network
func (r ApiSearchTokenMetadataV2Request) Network(network string) ApiSearchTokenMetadataV2Request {
	r.network = &network
	return r
}

func (r ApiSearchTokenMetadataV2Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.SearchTokenMetadataV2Execute(r)
}

/*
SearchTokenMetadataV2 Method for SearchTokenMetadataV2

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchTokenMetadataV2Request
*/
func (a *LoopringDEXRestfulAPIApiService) SearchTokenMetadataV2(ctx context.Context) ApiSearchTokenMetadataV2Request {
	return ApiSearchTokenMetadataV2Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *LoopringDEXRestfulAPIApiService) SearchTokenMetadataV2Execute(r ApiSearchTokenMetadataV2Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.SearchTokenMetadataV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/token/metadata"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tokenAddresses == nil {
		return localVarReturnValue, nil, reportError("tokenAddresses is required and must be specified")
	}
	if r.network == nil {
		return localVarReturnValue, nil, reportError("network is required and must be specified")
	}

	localVarQueryParams.Add("tokenAddresses", parameterToString(*r.tokenAddresses, ""))
	localVarQueryParams.Add("network", parameterToString(*r.network, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchTokenV2Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	network    *string
	key        *string
	offset     *int64
	limit      *int32
}

func (r ApiSearchTokenV2Request) Network(network string) ApiSearchTokenV2Request {
	r.network = &network
	return r
}

func (r ApiSearchTokenV2Request) Key(key string) ApiSearchTokenV2Request {
	r.key = &key
	return r
}

func (r ApiSearchTokenV2Request) Offset(offset int64) ApiSearchTokenV2Request {
	r.offset = &offset
	return r
}

func (r ApiSearchTokenV2Request) Limit(limit int32) ApiSearchTokenV2Request {
	r.limit = &limit
	return r
}

func (r ApiSearchTokenV2Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.SearchTokenV2Execute(r)
}

/*
SearchTokenV2 Method for SearchTokenV2

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchTokenV2Request
*/
func (a *LoopringDEXRestfulAPIApiService) SearchTokenV2(ctx context.Context) ApiSearchTokenV2Request {
	return ApiSearchTokenV2Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *LoopringDEXRestfulAPIApiService) SearchTokenV2Execute(r ApiSearchTokenV2Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.SearchTokenV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/tokens/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.network != nil {
		localVarQueryParams.Add("network", parameterToString(*r.network, ""))
	}
	if r.key != nil {
		localVarQueryParams.Add("key", parameterToString(*r.key, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSendLuckyTokenV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	body       *SendLuckyTokenRequestV3
}

// api.sendLuckyToken.implicit.value
func (r ApiSendLuckyTokenV3Request) Body(body SendLuckyTokenRequestV3) ApiSendLuckyTokenV3Request {
	r.body = &body
	return r
}

func (r ApiSendLuckyTokenV3Request) Execute() (*SubmitOffChainRequestItem, *http.Response, error) {
	return r.ApiService.SendLuckyTokenV3Execute(r)
}

/*
SendLuckyTokenV3 api.sendLuckyToken.value

api.sendLuckyToken.notes

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSendLuckyTokenV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) SendLuckyTokenV3(ctx context.Context) ApiSendLuckyTokenV3Request {
	return ApiSendLuckyTokenV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return SubmitOffChainRequestItem
func (a *LoopringDEXRestfulAPIApiService) SendLuckyTokenV3Execute(r ApiSendLuckyTokenV3Request) (*SubmitOffChainRequestItem, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SubmitOffChainRequestItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.SendLuckyTokenV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/luckyToken/sendLuckyToken"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSendTransactionV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	body       *ForwardEthTxRequest
}

// Body of send raw transaction
func (r ApiSendTransactionV3Request) Body(body ForwardEthTxRequest) ApiSendTransactionV3Request {
	r.body = &body
	return r
}

func (r ApiSendTransactionV3Request) Execute() (*ForwardEthTxResponse, *http.Response, error) {
	return r.ApiService.SendTransactionV3Execute(r)
}

/*
SendTransactionV3 Send a raw Ethereum transaction

Relay a raw Ethereum transaction to Ethereum mainnet.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSendTransactionV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) SendTransactionV3(ctx context.Context) ApiSendTransactionV3Request {
	return ApiSendTransactionV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return ForwardEthTxResponse
func (a *LoopringDEXRestfulAPIApiService) SendTransactionV3Execute(r ApiSendTransactionV3Request) (*ForwardEthTxResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ForwardEthTxResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.SendTransactionV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/eth/sendTx"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetReferrerV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
}

func (r ApiSetReferrerV3Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.SetReferrerV3Execute(r)
}

/*
SetReferrerV3 Method for SetReferrerV3

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSetReferrerV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) SetReferrerV3(ctx context.Context) ApiSetReferrerV3Request {
	return ApiSetReferrerV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *LoopringDEXRestfulAPIApiService) SetReferrerV3Execute(r ApiSetReferrerV3Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.SetReferrerV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/refer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubmitAmmPoolExitV2Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	body       *AmmPoolExitRequest
}

// api.submitAmmPoolExit.implicit.value
func (r ApiSubmitAmmPoolExitV2Request) Body(body AmmPoolExitRequest) ApiSubmitAmmPoolExitV2Request {
	r.body = &body
	return r
}

func (r ApiSubmitAmmPoolExitV2Request) Execute() (*SubmitOffChainRequestResponse, *http.Response, error) {
	return r.ApiService.SubmitAmmPoolExitV2Execute(r)
}

/*
SubmitAmmPoolExitV2 Exit an AMM pool

Return the exit request processing status

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubmitAmmPoolExitV2Request
*/
func (a *LoopringDEXRestfulAPIApiService) SubmitAmmPoolExitV2(ctx context.Context) ApiSubmitAmmPoolExitV2Request {
	return ApiSubmitAmmPoolExitV2Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return SubmitOffChainRequestResponse
func (a *LoopringDEXRestfulAPIApiService) SubmitAmmPoolExitV2Execute(r ApiSubmitAmmPoolExitV2Request) (*SubmitOffChainRequestResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SubmitOffChainRequestResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.SubmitAmmPoolExitV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/amm/exit"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubmitAmmPoolExitV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	body       *AmmPoolExitRequestV3
}

// AMM exit request params
func (r ApiSubmitAmmPoolExitV3Request) Body(body AmmPoolExitRequestV3) ApiSubmitAmmPoolExitV3Request {
	r.body = &body
	return r
}

func (r ApiSubmitAmmPoolExitV3Request) Execute() (*SubmitOffChainRequestItem, *http.Response, error) {
	return r.ApiService.SubmitAmmPoolExitV3Execute(r)
}

/*
SubmitAmmPoolExitV3 Exit an AMM pool

Return the exit request processing status

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubmitAmmPoolExitV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) SubmitAmmPoolExitV3(ctx context.Context) ApiSubmitAmmPoolExitV3Request {
	return ApiSubmitAmmPoolExitV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return SubmitOffChainRequestItem
func (a *LoopringDEXRestfulAPIApiService) SubmitAmmPoolExitV3Execute(r ApiSubmitAmmPoolExitV3Request) (*SubmitOffChainRequestItem, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SubmitOffChainRequestItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.SubmitAmmPoolExitV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/amm/exit"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubmitAmmPoolJoinV2Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	body       *AmmPoolJoinRequest
}

// api.AmmPoolJoinRequest.implicit.value
func (r ApiSubmitAmmPoolJoinV2Request) Body(body AmmPoolJoinRequest) ApiSubmitAmmPoolJoinV2Request {
	r.body = &body
	return r
}

func (r ApiSubmitAmmPoolJoinV2Request) Execute() (*SubmitOffChainRequestResponse, *http.Response, error) {
	return r.ApiService.SubmitAmmPoolJoinV2Execute(r)
}

/*
SubmitAmmPoolJoinV2 Join into AMM pool

Return the join request processing status

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubmitAmmPoolJoinV2Request
*/
func (a *LoopringDEXRestfulAPIApiService) SubmitAmmPoolJoinV2(ctx context.Context) ApiSubmitAmmPoolJoinV2Request {
	return ApiSubmitAmmPoolJoinV2Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return SubmitOffChainRequestResponse
func (a *LoopringDEXRestfulAPIApiService) SubmitAmmPoolJoinV2Execute(r ApiSubmitAmmPoolJoinV2Request) (*SubmitOffChainRequestResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SubmitOffChainRequestResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.SubmitAmmPoolJoinV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/amm/join"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubmitAmmPoolJoinV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	body       *AmmPoolJoinRequestV3
}

// AMM join request params
func (r ApiSubmitAmmPoolJoinV3Request) Body(body AmmPoolJoinRequestV3) ApiSubmitAmmPoolJoinV3Request {
	r.body = &body
	return r
}

func (r ApiSubmitAmmPoolJoinV3Request) Execute() (*SubmitOffChainRequestItem, *http.Response, error) {
	return r.ApiService.SubmitAmmPoolJoinV3Execute(r)
}

/*
SubmitAmmPoolJoinV3 Join into AMM pool

Return the join request processing status

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubmitAmmPoolJoinV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) SubmitAmmPoolJoinV3(ctx context.Context) ApiSubmitAmmPoolJoinV3Request {
	return ApiSubmitAmmPoolJoinV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return SubmitOffChainRequestItem
func (a *LoopringDEXRestfulAPIApiService) SubmitAmmPoolJoinV3Execute(r ApiSubmitAmmPoolJoinV3Request) (*SubmitOffChainRequestItem, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SubmitOffChainRequestItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.SubmitAmmPoolJoinV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/amm/join"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubmitDualAuthTransferV2Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	body       *DualAuthTransferRequest
}

// Submit dual authority transfer post message body
func (r ApiSubmitDualAuthTransferV2Request) Body(body DualAuthTransferRequest) ApiSubmitDualAuthTransferV2Request {
	r.body = &body
	return r
}

func (r ApiSubmitDualAuthTransferV2Request) Execute() (*SubmitOffChainRequestResponse, *http.Response, error) {
	return r.ApiService.SubmitDualAuthTransferV2Execute(r)
}

/*
SubmitDualAuthTransferV2 Submit dual authority transfer

Submit dual authority transfer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubmitDualAuthTransferV2Request
*/
func (a *LoopringDEXRestfulAPIApiService) SubmitDualAuthTransferV2(ctx context.Context) ApiSubmitDualAuthTransferV2Request {
	return ApiSubmitDualAuthTransferV2Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return SubmitOffChainRequestResponse
func (a *LoopringDEXRestfulAPIApiService) SubmitDualAuthTransferV2Execute(r ApiSubmitDualAuthTransferV2Request) (*SubmitOffChainRequestResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SubmitOffChainRequestResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.SubmitDualAuthTransferV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/dualAuthTransfer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubmitMintNftV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	body       *SubmitNftMintRequest
}

// Mint a NFT token in Loopring L2
func (r ApiSubmitMintNftV3Request) Body(body SubmitNftMintRequest) ApiSubmitMintNftV3Request {
	r.body = &body
	return r
}

func (r ApiSubmitMintNftV3Request) Execute() (*SubmitMintNftResponseItem, *http.Response, error) {
	return r.ApiService.SubmitMintNftV3Execute(r)
}

/*
SubmitMintNftV3 Mint a NFT token in Loopring L2

Mint a NFT token in Loopring L2

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubmitMintNftV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) SubmitMintNftV3(ctx context.Context) ApiSubmitMintNftV3Request {
	return ApiSubmitMintNftV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return SubmitMintNftResponseItem
func (a *LoopringDEXRestfulAPIApiService) SubmitMintNftV3Execute(r ApiSubmitMintNftV3Request) (*SubmitMintNftResponseItem, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SubmitMintNftResponseItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.SubmitMintNftV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/nft/mint"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubmitNftTradeV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	body       *SubmitNftTradeRequestV3
}

// Settle down an NFT trade which has two matched orders
func (r ApiSubmitNftTradeV3Request) Body(body SubmitNftTradeRequestV3) ApiSubmitNftTradeV3Request {
	r.body = &body
	return r
}

func (r ApiSubmitNftTradeV3Request) Execute() (*NftTradeResponse, *http.Response, error) {
	return r.ApiService.SubmitNftTradeV3Execute(r)
}

/*
SubmitNftTradeV3 Settle down an NFT trade which has two matched orders

Settle down an NFT trade which has two matched orders

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubmitNftTradeV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) SubmitNftTradeV3(ctx context.Context) ApiSubmitNftTradeV3Request {
	return ApiSubmitNftTradeV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return NftTradeResponse
func (a *LoopringDEXRestfulAPIApiService) SubmitNftTradeV3Execute(r ApiSubmitNftTradeV3Request) (*NftTradeResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *NftTradeResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.SubmitNftTradeV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/nft/trade"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubmitNftTransferV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	body       *NftTransferRequest
}

// api.submitNftTransfer.implicit.value
func (r ApiSubmitNftTransferV3Request) Body(body NftTransferRequest) ApiSubmitNftTransferV3Request {
	r.body = &body
	return r
}

func (r ApiSubmitNftTransferV3Request) Execute() (*SubmitOffChainRequestItem, *http.Response, error) {
	return r.ApiService.SubmitNftTransferV3Execute(r)
}

/*
SubmitNftTransferV3 Submit internal NFT transfer

api.submitNftTransfer.notes

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubmitNftTransferV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) SubmitNftTransferV3(ctx context.Context) ApiSubmitNftTransferV3Request {
	return ApiSubmitNftTransferV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return SubmitOffChainRequestItem
func (a *LoopringDEXRestfulAPIApiService) SubmitNftTransferV3Execute(r ApiSubmitNftTransferV3Request) (*SubmitOffChainRequestItem, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SubmitOffChainRequestItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.SubmitNftTransferV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/nft/transfer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubmitOffChainNftWithdrawalV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	body       *NftOffChainWithdrawalRequestV3
}

// Withdraw a NFT token
func (r ApiSubmitOffChainNftWithdrawalV3Request) Body(body NftOffChainWithdrawalRequestV3) ApiSubmitOffChainNftWithdrawalV3Request {
	r.body = &body
	return r
}

func (r ApiSubmitOffChainNftWithdrawalV3Request) Execute() (*SubmitOffChainRequestItem, *http.Response, error) {
	return r.ApiService.SubmitOffChainNftWithdrawalV3Execute(r)
}

/*
SubmitOffChainNftWithdrawalV3 Withdraw a NFT token

Withdraw a NFT token

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubmitOffChainNftWithdrawalV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) SubmitOffChainNftWithdrawalV3(ctx context.Context) ApiSubmitOffChainNftWithdrawalV3Request {
	return ApiSubmitOffChainNftWithdrawalV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return SubmitOffChainRequestItem
func (a *LoopringDEXRestfulAPIApiService) SubmitOffChainNftWithdrawalV3Execute(r ApiSubmitOffChainNftWithdrawalV3Request) (*SubmitOffChainRequestItem, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SubmitOffChainRequestItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.SubmitOffChainNftWithdrawalV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/nft/withdrawal"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubmitOffChainWithdrawalV2Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	body       *OffChainWithdrawalRequest
}

// Submit offchain withdraw request post message body
func (r ApiSubmitOffChainWithdrawalV2Request) Body(body OffChainWithdrawalRequest) ApiSubmitOffChainWithdrawalV2Request {
	r.body = &body
	return r
}

func (r ApiSubmitOffChainWithdrawalV2Request) Execute() (*SubmitOffChainRequestResponse, *http.Response, error) {
	return r.ApiService.SubmitOffChainWithdrawalV2Execute(r)
}

/*
SubmitOffChainWithdrawalV2 Submit offchain withdraw request

Submit offchain withdraw request

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubmitOffChainWithdrawalV2Request
*/
func (a *LoopringDEXRestfulAPIApiService) SubmitOffChainWithdrawalV2(ctx context.Context) ApiSubmitOffChainWithdrawalV2Request {
	return ApiSubmitOffChainWithdrawalV2Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return SubmitOffChainRequestResponse
func (a *LoopringDEXRestfulAPIApiService) SubmitOffChainWithdrawalV2Execute(r ApiSubmitOffChainWithdrawalV2Request) (*SubmitOffChainRequestResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SubmitOffChainRequestResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.SubmitOffChainWithdrawalV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/user/withdrawals"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubmitOffChainWithdrawalV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	body       *OffChainWithdrawalRequestV3
}

// Submit offchain withdraw request post message body
func (r ApiSubmitOffChainWithdrawalV3Request) Body(body OffChainWithdrawalRequestV3) ApiSubmitOffChainWithdrawalV3Request {
	r.body = &body
	return r
}

func (r ApiSubmitOffChainWithdrawalV3Request) Execute() (*SubmitOffChainRequestItem, *http.Response, error) {
	return r.ApiService.SubmitOffChainWithdrawalV3Execute(r)
}

/*
SubmitOffChainWithdrawalV3 Submit offchain withdraw request

Submit offchain withdraw request

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubmitOffChainWithdrawalV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) SubmitOffChainWithdrawalV3(ctx context.Context) ApiSubmitOffChainWithdrawalV3Request {
	return ApiSubmitOffChainWithdrawalV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return SubmitOffChainRequestItem
func (a *LoopringDEXRestfulAPIApiService) SubmitOffChainWithdrawalV3Execute(r ApiSubmitOffChainWithdrawalV3Request) (*SubmitOffChainRequestItem, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SubmitOffChainRequestItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.SubmitOffChainWithdrawalV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/user/withdrawals"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubmitOrderV2V2Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	body       *SubmitOrderRequest
}

// api.submitOrderV2.implicit.value
func (r ApiSubmitOrderV2V2Request) Body(body SubmitOrderRequest) ApiSubmitOrderV2V2Request {
	r.body = &body
	return r
}

func (r ApiSubmitOrderV2V2Request) Execute() (*SubmitOrderResponseV2, *http.Response, error) {
	return r.ApiService.SubmitOrderV2V2Execute(r)
}

/*
SubmitOrderV2V2 api.submitOrderV2.value

api.submitOrderV2.notes

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubmitOrderV2V2Request
*/
func (a *LoopringDEXRestfulAPIApiService) SubmitOrderV2V2(ctx context.Context) ApiSubmitOrderV2V2Request {
	return ApiSubmitOrderV2V2Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return SubmitOrderResponseV2
func (a *LoopringDEXRestfulAPIApiService) SubmitOrderV2V2Execute(r ApiSubmitOrderV2V2Request) (*SubmitOrderResponseV2, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SubmitOrderResponseV2
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.SubmitOrderV2V2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubmitOrderV3V3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	body       *SubmitOrderRequestV3
}

// Submit order message body
func (r ApiSubmitOrderV3V3Request) Body(body SubmitOrderRequestV3) ApiSubmitOrderV3V3Request {
	r.body = &body
	return r
}

func (r ApiSubmitOrderV3V3Request) Execute() (*SubmitOrderResponseItemV3, *http.Response, error) {
	return r.ApiService.SubmitOrderV3V3Execute(r)
}

/*
SubmitOrderV3V3 Submit an order

Submit an order

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubmitOrderV3V3Request
*/
func (a *LoopringDEXRestfulAPIApiService) SubmitOrderV3V3(ctx context.Context) ApiSubmitOrderV3V3Request {
	return ApiSubmitOrderV3V3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return SubmitOrderResponseItemV3
func (a *LoopringDEXRestfulAPIApiService) SubmitOrderV3V3Execute(r ApiSubmitOrderV3V3Request) (*SubmitOrderResponseItemV3, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SubmitOrderResponseItemV3
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.SubmitOrderV3V3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubmitRecommendedMarketsV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
}

func (r ApiSubmitRecommendedMarketsV3Request) Execute() (*GetExchangeFeeInfoResponseData, *http.Response, error) {
	return r.ApiService.SubmitRecommendedMarketsV3Execute(r)
}

/*
SubmitRecommendedMarketsV3 api.getRecommendedMarkets.value

api.getRecommendedMarkets.notes

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubmitRecommendedMarketsV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) SubmitRecommendedMarketsV3(ctx context.Context) ApiSubmitRecommendedMarketsV3Request {
	return ApiSubmitRecommendedMarketsV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GetExchangeFeeInfoResponseData
func (a *LoopringDEXRestfulAPIApiService) SubmitRecommendedMarketsV3Execute(r ApiSubmitRecommendedMarketsV3Request) (*GetExchangeFeeInfoResponseData, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetExchangeFeeInfoResponseData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.SubmitRecommendedMarketsV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/exchange/recommended"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubmitRewardV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
}

func (r ApiSubmitRewardV3Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.SubmitRewardV3Execute(r)
}

/*
SubmitRewardV3 Method for SubmitRewardV3

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubmitRewardV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) SubmitRewardV3(ctx context.Context) ApiSubmitRewardV3Request {
	return ApiSubmitRewardV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *LoopringDEXRestfulAPIApiService) SubmitRewardV3Execute(r ApiSubmitRewardV3Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.SubmitRewardV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/reward"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubmitTransferV2Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	body       *OriginTransferRequest
}

// Submit internal transfer post message body
func (r ApiSubmitTransferV2Request) Body(body OriginTransferRequest) ApiSubmitTransferV2Request {
	r.body = &body
	return r
}

func (r ApiSubmitTransferV2Request) Execute() (*SubmitOffChainRequestResponse, *http.Response, error) {
	return r.ApiService.SubmitTransferV2Execute(r)
}

/*
SubmitTransferV2 Submit internal transfer

Submit internal transfer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubmitTransferV2Request
*/
func (a *LoopringDEXRestfulAPIApiService) SubmitTransferV2(ctx context.Context) ApiSubmitTransferV2Request {
	return ApiSubmitTransferV2Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return SubmitOffChainRequestResponse
func (a *LoopringDEXRestfulAPIApiService) SubmitTransferV2Execute(r ApiSubmitTransferV2Request) (*SubmitOffChainRequestResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SubmitOffChainRequestResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.SubmitTransferV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/transfer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubmitTransferV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	body       *OriginTransferRequestV3
}

// Submit internal transfer post message body
func (r ApiSubmitTransferV3Request) Body(body OriginTransferRequestV3) ApiSubmitTransferV3Request {
	r.body = &body
	return r
}

func (r ApiSubmitTransferV3Request) Execute() (*SubmitOffChainRequestItem, *http.Response, error) {
	return r.ApiService.SubmitTransferV3Execute(r)
}

/*
SubmitTransferV3 Submit internal transfer

Submit internal transfer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubmitTransferV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) SubmitTransferV3(ctx context.Context) ApiSubmitTransferV3Request {
	return ApiSubmitTransferV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return SubmitOffChainRequestItem
func (a *LoopringDEXRestfulAPIApiService) SubmitTransferV3Execute(r ApiSubmitTransferV3Request) (*SubmitOffChainRequestItem, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SubmitOffChainRequestItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.SubmitTransferV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/transfer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubmitUpdateAccountV2Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	body       *UpdateAccountRequest
}

// api.submitUpdateAccount.implicit.value
func (r ApiSubmitUpdateAccountV2Request) Body(body UpdateAccountRequest) ApiSubmitUpdateAccountV2Request {
	r.body = &body
	return r
}

func (r ApiSubmitUpdateAccountV2Request) Execute() (*SubmitOffChainRequestResponse, *http.Response, error) {
	return r.ApiService.SubmitUpdateAccountV2Execute(r)
}

/*
SubmitUpdateAccountV2 Update account EDDSA key

Updates the EDDSA key associated with the specified account, making the previous one invalid in the process.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubmitUpdateAccountV2Request
*/
func (a *LoopringDEXRestfulAPIApiService) SubmitUpdateAccountV2(ctx context.Context) ApiSubmitUpdateAccountV2Request {
	return ApiSubmitUpdateAccountV2Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return SubmitOffChainRequestResponse
func (a *LoopringDEXRestfulAPIApiService) SubmitUpdateAccountV2Execute(r ApiSubmitUpdateAccountV2Request) (*SubmitOffChainRequestResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SubmitOffChainRequestResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.SubmitUpdateAccountV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/account"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubmitUpdateAccountV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	body       *UpdateAccountRequestV3
}

// api.submitUpdateAccount.implicit.value
func (r ApiSubmitUpdateAccountV3Request) Body(body UpdateAccountRequestV3) ApiSubmitUpdateAccountV3Request {
	r.body = &body
	return r
}

func (r ApiSubmitUpdateAccountV3Request) Execute() (*SubmitOffChainRequestItem, *http.Response, error) {
	return r.ApiService.SubmitUpdateAccountV3Execute(r)
}

/*
SubmitUpdateAccountV3 Update account EDDSA key

Updates the EDDSA key associated with the specified account, making the previous one invalid in the process.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubmitUpdateAccountV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) SubmitUpdateAccountV3(ctx context.Context) ApiSubmitUpdateAccountV3Request {
	return ApiSubmitUpdateAccountV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return SubmitOffChainRequestItem
func (a *LoopringDEXRestfulAPIApiService) SubmitUpdateAccountV3Execute(r ApiSubmitUpdateAccountV3Request) (*SubmitOffChainRequestItem, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SubmitOffChainRequestItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.SubmitUpdateAccountV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/account"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTokenMetadatasV2Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	network    *string
	offset     *int64
	limit      *int32
}

func (r ApiTokenMetadatasV2Request) Network(network string) ApiTokenMetadatasV2Request {
	r.network = &network
	return r
}

func (r ApiTokenMetadatasV2Request) Offset(offset int64) ApiTokenMetadatasV2Request {
	r.offset = &offset
	return r
}

func (r ApiTokenMetadatasV2Request) Limit(limit int32) ApiTokenMetadatasV2Request {
	r.limit = &limit
	return r
}

func (r ApiTokenMetadatasV2Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.TokenMetadatasV2Execute(r)
}

/*
TokenMetadatasV2 Method for TokenMetadatasV2

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTokenMetadatasV2Request
*/
func (a *LoopringDEXRestfulAPIApiService) TokenMetadatasV2(ctx context.Context) ApiTokenMetadatasV2Request {
	return ApiTokenMetadatasV2Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *LoopringDEXRestfulAPIApiService) TokenMetadatasV2Execute(r ApiTokenMetadatasV2Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.TokenMetadatasV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/tokens/metadata"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.network != nil {
		localVarQueryParams.Add("network", parameterToString(*r.network, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidateNftOrderV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	body       *SubmitNftOrderRequestV3
}

// Validate a NFT order
func (r ApiValidateNftOrderV3Request) Body(body SubmitNftOrderRequestV3) ApiValidateNftOrderV3Request {
	r.body = &body
	return r
}

func (r ApiValidateNftOrderV3Request) Execute() (*SubmitOffChainRequestItem, *http.Response, error) {
	return r.ApiService.ValidateNftOrderV3Execute(r)
}

/*
ValidateNftOrderV3 Validate a NFT order

Validate a NFT order

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiValidateNftOrderV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) ValidateNftOrderV3(ctx context.Context) ApiValidateNftOrderV3Request {
	return ApiValidateNftOrderV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return SubmitOffChainRequestItem
func (a *LoopringDEXRestfulAPIApiService) ValidateNftOrderV3Execute(r ApiValidateNftOrderV3Request) (*SubmitOffChainRequestItem, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SubmitOffChainRequestItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.ValidateNftOrderV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/nft/validateOrder"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVerifyAllEcdsaV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
}

func (r ApiVerifyAllEcdsaV3Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.VerifyAllEcdsaV3Execute(r)
}

/*
VerifyAllEcdsaV3 Method for VerifyAllEcdsaV3

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVerifyAllEcdsaV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) VerifyAllEcdsaV3(ctx context.Context) ApiVerifyAllEcdsaV3Request {
	return ApiVerifyAllEcdsaV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *LoopringDEXRestfulAPIApiService) VerifyAllEcdsaV3Execute(r ApiVerifyAllEcdsaV3Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.VerifyAllEcdsaV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/verifyAllEcdsa"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWithdrawLuckyTokenV3Request struct {
	ctx        context.Context
	ApiService *LoopringDEXRestfulAPIApiService
	body       *WithdrawLuckyTokenRequestV3
}

// api.withdrawLuckyToken.implicit.value
func (r ApiWithdrawLuckyTokenV3Request) Body(body WithdrawLuckyTokenRequestV3) ApiWithdrawLuckyTokenV3Request {
	r.body = &body
	return r
}

func (r ApiWithdrawLuckyTokenV3Request) Execute() (*SubmitOffChainRequestItem, *http.Response, error) {
	return r.ApiService.WithdrawLuckyTokenV3Execute(r)
}

/*
WithdrawLuckyTokenV3 api.withdrawLuckyToken.value

api.withdrawLuckyToken.notes

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWithdrawLuckyTokenV3Request
*/
func (a *LoopringDEXRestfulAPIApiService) WithdrawLuckyTokenV3(ctx context.Context) ApiWithdrawLuckyTokenV3Request {
	return ApiWithdrawLuckyTokenV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return SubmitOffChainRequestItem
func (a *LoopringDEXRestfulAPIApiService) WithdrawLuckyTokenV3Execute(r ApiWithdrawLuckyTokenV3Request) (*SubmitOffChainRequestItem, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SubmitOffChainRequestItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoopringDEXRestfulAPIApiService.WithdrawLuckyTokenV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/luckyToken/user/withdrawals"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
